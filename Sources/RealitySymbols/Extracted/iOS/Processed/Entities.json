[{"name":"AnchorEntity","comment":"An anchor that tethers entities to a scene.  Use anchor entities to control how RealityKit places virtual objects into your scene. ``AnchorEntity`` conforms to the ``HasAnchoring`` protocol, which gives it an ``AnchoringComponent`` instance.  RealityKit places anchors based on the anchoring component’s ``AnchoringComponent\/target-swift.property`` property. For example, you can configure an anchor entity to rest on a detected horizontal surface in an AR scene like a table or floor, and RealityKit automatically places that anchor once it detects an appropriate horizontal plane in the real world.  For information on the different types of anchors available when using Reality Composer, see <doc:selecting-an-anchor-for-a-reality-composer-scene>.  ![Diagram showing the components present in the anchor entity. It contains three boxes labeled Transform component, Synchronization component, and Anchoring component.](AnchorEntity-1)  Add anchor entities directly to your scene’s ``Scene\/anchors`` collection, or anywhere else in the scene hierarchy by adding them to the ``Entity\/children`` collection of another entity in your scene. Because ``AnchorEntity`` is a subclass of ``Entity``, you can make an anchor entity a child of any other entity. RealityKit may move anchor entities as the scene updates, so the location and rotation of the anchor entity may change relative to its parent, even if your code never modifies its ``Entity\/transform`` property.  Some anchor entities may not show up in your scene at all if RealityKit fails to detect an appropriate place for them. For example, an anchor entity with an `image` target won’t show up in the scene until RealityKit detects the specified image in the real world.  ![Block diagram showing how anchor entities attach to a scene, and how they support entity hierarchies. The root box of the hierarchy diagram represents the ARView. It has one child representing the ARView’s scene, and that scene has two children, both of which are anchor entities. Each of the anchor entities have a hierarchy of child entities beneath them, most of which are labeled Entity, but one of the entities in the hierarchy is another anchor entity.](AnchorEntity-2)  You can have multiple anchors in a RealityKit scene. For example, one anchor could place a toy car on a horizontal surface, like a table, and another could tie an informative text bubbles to an image in the same scene.","properties":[{"complete":"@MainActor var anchorIdentifier: UUID? { get }","type":"UUID","comment":"The identifier of the AR anchor with which the anchor entity is associated, or `nil` if it isn’t currently anchored.","name":"anchorIdentifier"},{"name":"anchoring","complete":"@MainActor var anchoring: AnchoringComponent { get set }","type":"AnchoringComponent"}]},{"name":"BodyTrackedEntity","comment":"An entity used to animate a virtual character in an AR scene by tracking a real person.  Like a ``ModelEntity``, a ``BodyTrackedEntity`` has a ``ModelComponent`` that defines its physical appearance. Unlike a model entity, a body-tracked entity lacks the components required to participate in collisions or physics simulations. Instead, a ``BodyTrackingComponent`` drives the positioning and arrangement of the entity based on tracking information from the AR session.  ![Diagram showing the components present in the body-tracked entity.](BodyTrackedEntity-1)  For an example of how to use a body-tracked entity, see <doc:\/\/com.apple.documentation\/documentation\/arkit\/content_anchors\/capturing_body_motion_in_3d>.","properties":[{"complete":"@MainActor var jointTransforms: [Transform] { get set }","type":"[Transform]","name":"jointTransforms","comment":"The relative joint transforms of the model entity.  Call ``RealityKit\/BodyTrackedEntity\/jointNames`` to determine the name and order of the joints.  - Note: Active animations may override the joint transforms set using this property.."},{"type":"ModelDebugOptionsComponent","name":"debugModel","complete":"@MainActor var debugModel: ModelDebugOptionsComponent? { get set }"},{"name":"jointNames","type":"[String]","complete":"@MainActor var jointNames: [String] { get }","comment":"The names of all the joints in the model entity."},{"type":"ModelComponent","name":"model","complete":"@MainActor var model: ModelComponent? { get set }","comment":"The model component for the entity."},{"name":"bodyTracking","complete":"@MainActor var bodyTracking: BodyTrackingComponent { get set }","comment":"The body-tracking component for the body-tracked entity.","type":"BodyTrackingComponent"},{"name":"modelDebugOptions","type":"ModelDebugOptionsComponent","complete":"@MainActor var modelDebugOptions: ModelDebugOptionsComponent? { get set }","comment":"Configures the debug visualization of this model."}]},{"properties":[{"name":"shadow","complete":"@MainActor var shadow: DirectionalLightComponent.Shadow? { get set }","type":"DirectionalLightComponent.Shadow","comment":"The shadow settings for a directional light.  Set this value to `nil` to remove shadows."},{"comment":"A directional light component for the entity.","name":"light","type":"DirectionalLightComponent","complete":"@MainActor var light: DirectionalLightComponent { get set }"}],"name":"DirectionalLight","comment":"An entity that casts a virtual light in a particular direction.  During an AR session, RealityKit automatically lights your virtual objects to match real-world lighting. You can also explicitly add virtual lights that act upon your virtual content. This is typically most useful outside of an AR session (with the view’s ``ARView\/cameraMode-swift.property`` property set to ``ARView\/CameraMode-swift.enum\/nonAR``).  A directional light uniformly casts light along its z-axis—specifically, along `(0, 0, -1)`. Use the light’s `look(at:from:upVector:relativeTo:)` method to aim the light in a particular direction.  You can configure the light’s color and intensity. You can also control how or if it casts a shadow.  A RealityKit scene can contain up to eight dynamic lights, which are ``SpotLight``, ``PointLight``, and ``DirectionalLight`` entities. This limit doesn’t include light from image-based lighting."},{"comment":"An element of a RealityKit scene to which you attach components that provide appearance and behavior characteristics for the entity.  You create and configure entities to embody objects that you want to place in the real world in an AR app. You do this by adding ``Entity`` instances to the ``Scene`` instance associated with an ``ARView``.  RealityKit defines a few concrete subclasses of ``Entity`` that provide commonly used functionality. For example, you typically start by creating an instance of ``AnchorEntity`` to anchor your content, and add the anchor to a scene’s ``Scene\/anchors`` collection. You might then instantiate a ``ModelEntity`` to represent a physical object in the scene, and add that as a child entity to the anchor. You can also create custom entities, and add them either to an anchor, or as children of another entity.  ![Block diagram showing how entity hierarchies, composed of different kinds of entities, attach to a scene, which is itself a child of the AR view.](Entity-1)  You can load predefined entities or a hierarchy of entities from your app’s bundle, or from a file on disk, using the methods in <doc:stored-entities>. Alternatively, you can create entities programmatically.  Entities contain components (instances conforming to the ``Component`` protocol) that provide appearance and behaviors for the entity. For example, the ``Transform`` component contains the scale, rotation, and translation information needed to position an entity in space. You store components in the entity’s ``Entity\/components`` collection, which can hold exactly one of any component type. It makes sense to have only a single ``Transform`` component, one ``ModelComponent`` (specifying the visual appearance of the entity), and so on.  ![Diagram showing the components present in the base entity class, as well as in the derived anchor entity and model entity classes.](Entity-2)  All entities inherit a few common components from the ``Entity`` base class: the ``Transform`` component for spatial positioning, and ``SynchronizationComponent``, which enables synchronization of the entity among networked peers. Specific types of entities define additional behaviors. For example, the model entity has components for visual appearance (``ModelComponent``), collision detection (``CollisionComponent``), and physics simulations (``PhysicsBodyComponent`` and ``PhysicsMotionComponent``).","name":"Entity","properties":[{"complete":"@MainActor var id: UInt64 { get }","type":"UInt64","comment":"The stable identity of the entity associated with this instance.","name":"id"},{"complete":"@MainActor var characterController: CharacterControllerComponent? { get set }","comment":"The character controller component for the entity.","type":"CharacterControllerComponent","name":"characterController"},{"name":"defaultAnimationClock","comment":"Returns the default animation clock for this entity.","complete":"@MainActor var defaultAnimationClock: CMClockOrTimebase { get set }","type":"CMClockOrTimebase"},{"name":"position","complete":"@MainActor var position: SIMD3<Float> { get set }","type":"SIMD3<Float>","comment":"The position of the entity relative to its parent.  This value is the entity’s position relative to its parent. To get the world-space position of the entity in the scene, use ``HasTransform\/position(relativeTo:)``, passing `nil` as the reference entity.  This is the same as the ``Transform\/translation`` value on the ``HasTransform\/transform``."},{"complete":"@MainActor var bindableValues: BindableValuesReference { get set }","name":"bindableValues","type":"BindableValuesReference"},{"name":"synchronization","type":"SynchronizationComponent","comment":"The entity’s synchronization component.","complete":"@MainActor var synchronization: SynchronizationComponent? { get set }"},{"complete":"@MainActor var transform: Transform { get set }","name":"transform","type":"Transform","comment":"The transform of an entity relative to its parent.  For an ``AnchorEntity`` instance, the transform is relative to the AR anchor."},{"type":"Bool","comment":"A Boolean that indicates whether the entity and all of its ancestors are enabled.  The value of this property is `true` if the entity and all of its ancestors are enabled, regardless of anchor state.","complete":"@MainActor var isEnabledInHierarchy: Bool { get }","name":"isEnabledInHierarchy"},{"name":"scale","type":"SIMD3<Float>","complete":"@MainActor var scale: SIMD3<Float> { get set }","comment":"The scale of the entity relative to its parent.  This value is the entity’s scale relative to its parent. To get the actual scale of the entity in the scene, use ``HasTransform\/scale(relativeTo:)``, passing `nil` as the reference entity.  This is the same as the ``Transform\/scale`` value on the ``HasTransform\/transform``."},{"name":"availableAnimations","comment":"The list of animations associated with the entity.  When you import an entity from a file, for example by using the ``Entity\/load(named:in:)`` method, the entity might contain associated animations. Any that RealityKit supports appear in the ``Entity\/availableAnimations`` array.  To play a particular animation resource from the list, call the ``Entity\/playAnimation(_:transitionDuration:startsPaused:)`` method. Alternatively, to play all animations with a given name, call the `playAnimation(named:transitionDuration:startsPaused:)` method instead.","complete":"@MainActor var availableAnimations: [AnimationResource] { get }","type":"[AnimationResource]"},{"name":"anchor","complete":"@MainActor var anchor: (HasAnchoring)? { get }","type":"(HasAnchoring)","comment":"The nearest ancestor entity that can act as an anchor.  This property returns `nil` if no ancestor can act as an anchor. An entity can act as an anchor if it adopts the ``HasAnchoring`` protocol. Just because an ancestor can be anchored doesn’t mean that it is. Inspect the ``Entity\/isAnchored`` property to see if an entity (or one of its ancestors) is anchored."},{"name":"isAnchored","comment":"A Boolean that indicates whether the entity is anchored.  The value of this property is `true` if the entity is anchored in a scene. An entity that isn’t anchored becomes inactive (``Entity\/isActive`` returns `false`), meaning RealityKit doesn’t render or simulate it.","type":"Bool","complete":"@MainActor var isAnchored: Bool { get }"},{"type":"Entity","name":"parent","complete":"@MainActor var parent: Entity? { get }","comment":"The parent entity.  An entity has at most one parent entity. If an entity isn’t part of a hierarchy, or if it is a root entity, the ``HasHierarchy\/parent`` property is `nil`.  Use the ``HasHierarchy\/setParent(_:preservingWorldTransform:)`` method to change an entity’s parent. Use the ``HasHierarchy\/removeFromParent(preservingWorldTransform:)`` method to remove the parent. These methods automatically update the corresponding ``HasHierarchy\/children`` collections of the new and old parent."},{"name":"parameters","comment":"Represents a reference to the parameters for a particular entity.","type":"Entity.ParameterSet","complete":"@MainActor var parameters: Entity.ParameterSet { get set }"},{"name":"isAccessibilityElement","complete":"@MainActor var isAccessibilityElement: Bool { get set }","comment":"A Boolean value indicating whether the receiver is an accessibility element that an assistive application can access.","type":"Bool"},{"complete":"@MainActor var characterControllerState: CharacterControllerStateComponent? { get set }","type":"CharacterControllerStateComponent","name":"characterControllerState","comment":"The character controller state for  the entity."},{"comment":"The hash value.  Hash values are not guaranteed to be equal across different executions of your program. Do not save hash values to use during a future execution.  - Important: `hashValue` is deprecated as a `Hashable` requirement. To   conform to `Hashable`, implement the `hash(into:)` requirement instead.   The compiler provides an implementation for `hashValue` for you.","complete":"nonisolated var hashValue: Int { get }","type":"Int","name":"hashValue"},{"comment":"A Boolean that you set to enable or disable the entity and its descendants.  Set this value to `true` to enable the entity. Unless an ancestor is disabled, the entity and all of its enabled descendants, up to the first that’s disabled, report ``Entity\/isEnabledInHierarchy`` of `true`. If an ancestor is disabled, they all report `false`. The state of ``Entity\/isActive`` for enabled entities is `true` if they are anchored, or `false` otherwise.  If you disable an entity, it and all of its descendants become both disabled (``Entity\/isEnabledInHierarchy`` returns `false`) and inactive (``Entity\/isActive`` returns `false`), regardless of any other state.","name":"isEnabled","type":"Bool","complete":"@MainActor var isEnabled: Bool { get set }"},{"type":"String","complete":"@MainActor var accessibilityDescription: String? { get set }","comment":"A longer description of the entity for use by assistive technologies.","name":"accessibilityDescription"},{"name":"debugDescription","complete":"@MainActor var debugDescription: String { get }","comment":"A human readable description of the entity.","type":"String"},{"complete":"@MainActor var orientation: simd_quatf { get set }","name":"orientation","type":"simd_quatf","comment":"The rotation of the entity relative to its parent.  This value is the entity’s rotation relative to its parent. To get the world-space orientation of the entity, use ``HasTransform\/orientation(relativeTo:)``, passing `nil` as the reference entity.  This is the same as the ``Transform\/rotation`` value on the ``HasTransform\/transform``."},{"complete":"@MainActor var children: Entity.ChildCollection { get set }","comment":"The child entities that the entity manages.  An entity can have any number of child entities.  Use the ``HasHierarchy\/addChild(_:preservingWorldTransform:)`` method to add a child to an entity. Use the ``HasHierarchy\/removeChild(_:preservingWorldTransform:)`` method to remove one from an entity. These methods automatically update the ``HasHierarchy\/parent`` properties of the child entities.","type":"Entity.ChildCollection","name":"children"},{"type":"Scene","name":"scene","complete":"@MainActor var scene: Scene? { get }","comment":"The scene that owns the entity.  An entity belongs to a scene if the entity is part of a hierarchy that’s rooted in the scene’s ``Scene\/anchors`` collection.  The value of the property is `nil` if the entity isn’t currently attached to any scene."},{"comment":"A Boolean that indicates whether the calling process owns the entity.  The calling process owns the entity if the value is `true`.","complete":"@MainActor var isOwner: Bool { get }","name":"isOwner","type":"Bool"},{"comment":"The name of the entity.  You can find an entity by name in a scene by calling the scene’s ``Scene\/findEntity(named:)`` method. Or you can recursively search among the children of a given entity by calling the entity’s ``Entity\/findEntity(named:)`` method.  Entity names are not guaranteed to be unique. When you search by name, these methods return the first entity encountered with the given name.","name":"name","complete":"@MainActor var name: String { get set }","type":"String"},{"name":"isActive","comment":"A Boolean that indicates whether the entity is active.  The value of this property is `true` if the entity is anchored in a scene, and it and all of its ancestors are enabled (``Entity\/isEnabled`` is set to `true`). RealityKit doesn’t simulate or render inactive entities.","complete":"@MainActor var isActive: Bool { get }","type":"Bool"},{"name":"accessibilityLabel","complete":"@MainActor var accessibilityLabel: String? { get set }","type":"String","comment":"A succinct label that identifies the purpose of the image.  The default value for this property is `false`.  For entities with ``Entity\/isAccessibilityElement`` set to <doc:\/\/com.apple.documentation\/documentation\/swift\/true>, iOS uses this string to provide information to users of assistive technologies like VoiceOver. Set this property to a name or short description that accurately describes the entity. If you wish to provide additional information or a longer description of the entity, you can use ``Entity\/accessibilityDescription``."},{"comment":"All the components stored on the entity.  You can only store one component of a given type on an entity.","type":"Entity.ComponentSet","name":"components","complete":"@MainActor var components: Entity.ComponentSet { get set }"}]},{"comment":"A representation of a physical object that RealityKit renders and optionally simulates.  Use one or more model entities to place physical objects in a scene. In addition to the components they inherit from the ``Entity`` class, model entities have geometry, described by their ``ModelComponent``. Model entities acquire the model component by conforming to the ``HasModel`` protocol. You specify meshes and materials to control how a model entity appears.  ![Diagram showing the components present in the model entity.](ModelEntity-1)  Models respond to physics simulations because they conform to the ``HasPhysics`` protocol. You give them mass and other physical properties with a ``PhysicsBodyComponent`` instance, and then apply forces or impulses. The simulator uses a ``PhysicsMotionComponent`` to manage the linear and angular velocity of the object. Alternatively, you can selectively circumvent the simulation to control position and velocity yourself. Do this for a given model by setting its physics body ``PhysicsBodyComponent\/mode`` to ``PhysicsBodyMode\/kinematic``.  Models can also collide with one another, and with other entities that conform to the ``HasCollision`` protocol. The ``CollisionComponent`` provides parameters that let you manage which models collide with each other. It also lets you control the collision shape, which for performance reasons, is typically simpler than the visual geometry.","name":"ModelEntity","properties":[{"type":"ModelDebugOptionsComponent","name":"debugModel","complete":"@MainActor var debugModel: ModelDebugOptionsComponent? { get set }"},{"comment":"The relative joint transforms of the model entity.  Call ``RealityKit\/BodyTrackedEntity\/jointNames`` to determine the name and order of the joints.  - Note: Active animations may override the joint transforms set using this property..","complete":"@MainActor var jointTransforms: [Transform] { get set }","type":"[Transform]","name":"jointTransforms"},{"type":"ModelComponent","name":"model","complete":"@MainActor var model: ModelComponent? { get set }","comment":"The model component for the entity."},{"name":"physicsMotion","comment":"The physics motion component used by physics simulations of the model entity.","complete":"@MainActor var physicsMotion: PhysicsMotionComponent? { get set }","type":"PhysicsMotionComponent"},{"name":"modelDebugOptions","comment":"Configures the debug visualization of this model.","type":"ModelDebugOptionsComponent","complete":"@MainActor var modelDebugOptions: ModelDebugOptionsComponent? { get set }"},{"name":"jointNames","type":"[String]","complete":"@MainActor var jointNames: [String] { get }","comment":"The names of all the joints in the model entity."},{"type":"CollisionComponent","complete":"@MainActor var collision: CollisionComponent? { get set }","comment":"The collision component that gives the entity the ability to participate in collision simulations.","name":"collision"},{"complete":"@MainActor var physicsBody: PhysicsBodyComponent? { get set }","type":"PhysicsBodyComponent","name":"physicsBody","comment":"A component that is used for physics simulations of the model entity in accordance with the laws of Newtonian mechanics."}]},{"name":"PerspectiveCamera","properties":[{"comment":"A camera component for the perspective camera entity.","type":"PerspectiveCameraComponent","name":"camera","complete":"@MainActor var camera: PerspectiveCameraComponent { get set }"}],"comment":"A virtual camera that establishes the rendering perspective.  During an AR session, RealityKit automatically uses the device’s camera to define the perspective from which to render the scene. When rendering a scene outside of an AR session (with the view’s ``ARView\/cameraMode-swift.property`` property set to ``ARView\/CameraMode-swift.enum\/nonAR``), RealityKit uses a ``PerspectiveCamera`` instead. You can add a perspective camera anywhere in your scene to control the point of view. If you don't explicitly provide one, RealityKit creates a default camera for you."},{"name":"PointLight","properties":[{"name":"light","type":"PointLightComponent","comment":"A point light component for the entity.","complete":"@MainActor var light: PointLightComponent { get set }"}],"comment":"An entity that produces an omnidirectional light for virtual objects.  During an AR session, RealityKit automatically lights your virtual objects to match real-world lighting. You can also explicitly add virtual lights that act upon your virtual content. This is typically most useful outside of an AR session (with the view’s ``ARView\/cameraMode-swift.property`` property set to ``ARView\/CameraMode-swift.enum\/nonAR``).  The point light is an omnidirectional light that illuminates all the virtual content within a configurable radius from the light. You can configure the light’s color and intensity.  A RealityKit scene can contain up to eight dynamic lights, which are ``SpotLight``, ``PointLight``, and ``DirectionalLight`` entities. This limit doesn’t include light from image-based lighting."},{"comment":"An entity that illuminates virtual content in a cone-shaped volume.  During an AR session, RealityKit automatically lights your virtual objects to match real-world lighting. You can also explicitly add virtual lights that act upon your virtual content. This is typically most useful outside of an AR session (with the view’s ``ARView\/cameraMode-swift.property`` property set to ``ARView\/CameraMode-swift.enum\/nonAR``).  A RealityKit scene can contain up to eight dynamic lights, which are ``SpotLight``, ``PointLight``, and ``DirectionalLight`` entities. This limit doesn’t include light from image-based lighting.","name":"SpotLight","properties":[{"comment":"A spotlight component for the entity.","complete":"@MainActor var light: SpotLightComponent { get set }","type":"SpotLightComponent","name":"light"},{"complete":"@MainActor var shadow: SpotLightComponent.Shadow? { get set }","type":"SpotLightComponent.Shadow","name":"shadow","comment":"The shadow for the spotlight.  Set this property to `nil` to remove shadows for the light. Set it to an instance of ``SpotLightComponent\/Shadow`` to create shadows."}]},{"name":"TriggerVolume","properties":[{"type":"CollisionComponent","comment":"The collision component that gives the entity the ability to participate in collision simulations.","complete":"@MainActor var collision: CollisionComponent? { get set }","name":"collision"}],"comment":"An invisible 3D shape that detects when objects enter or exit a given region of space.  A trigger volume is an entity that can participate in collisions because it has a ``CollisionComponent``. You use a trigger volume as a sensor that indicates when another collision-capable entity, like a ``ModelEntity``, enters the region of space occupied by the trigger volume. You can use the generated ``CollisionEvents`` between the trigger volume and the other entity to trigger an action, like indicating to the user that a projectile hit its target.  ![Diagram showing the components present in the trigger volume entity.](TriggerVolume-1)  The trigger volume itself is very simple. It lacks any physical appearance, and doesn’t participate in physics simulations. This makes it very efficient for tasks that require only collision detection."}]
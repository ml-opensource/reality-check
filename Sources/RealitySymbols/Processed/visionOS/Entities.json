[{"name":"AnchorEntity","properties":[{"comment":"The identifier of the AR anchor with which the anchor entity is associated, or `nil` if it isn’t currently anchored.","name":"anchorIdentifier","type":"UUID","complete":"@MainActor var anchorIdentifier: UUID? { get }"},{"type":"AnchoringComponent","name":"anchoring","complete":"@MainActor var anchoring: AnchoringComponent { get set }"}],"comment":"An anchor that tethers entities to a scene.  Use anchor entities to control how RealityKit places virtual objects into your scene. ``AnchorEntity`` conforms to the ``HasAnchoring`` protocol, which gives it an ``AnchoringComponent`` instance.  RealityKit places anchors based on the anchoring component’s ``AnchoringComponent\/target-swift.property`` property. For example, you can configure an anchor entity to rest on a detected horizontal surface in an AR scene like a table or floor, and RealityKit automatically places that anchor once it detects an appropriate horizontal plane in the real world.  For information on the different types of anchors available when using Reality Composer, see <doc:selecting-an-anchor-for-a-reality-composer-scene>.  ![Diagram showing the components present in the anchor entity. It contains three boxes labeled Transform component, Synchronization component, and Anchoring component.](AnchorEntity-1)  Add anchor entities directly to your scene’s ``Scene\/anchors`` collection, or anywhere else in the scene hierarchy by adding them to the ``Entity\/children`` collection of another entity in your scene. Because ``AnchorEntity`` is a subclass of ``Entity``, you can make an anchor entity a child of any other entity. RealityKit may move anchor entities as the scene updates, so the location and rotation of the anchor entity may change relative to its parent, even if your code never modifies its ``Entity\/transform`` property.  Some anchor entities may not show up in your scene at all if RealityKit fails to detect an appropriate place for them. For example, an anchor entity with an `image` target won’t show up in the scene until RealityKit detects the specified image in the real world.  ![Block diagram showing how anchor entities attach to a scene, and how they support entity hierarchies. The root box of the hierarchy diagram represents the ARView. It has one child representing the ARView’s scene, and that scene has two children, both of which are anchor entities. Each of the anchor entities have a hierarchy of child entities beneath them, most of which are labeled Entity, but one of the entities in the hierarchy is another anchor entity.](AnchorEntity-2)  You can have multiple anchors in a RealityKit scene. For example, one anchor could place a toy car on a horizontal surface, like a table, and another could tie an informative text bubbles to an image in the same scene."},{"name":"Entity","properties":[{"comment":"The transform of an entity relative to its parent.  For an ``AnchorEntity`` instance, the transform is relative to the AR anchor.","type":"Transform","complete":"@MainActor var transform: Transform { get set }","name":"transform"},{"name":"isAnchored","type":"Bool","complete":"@MainActor var isAnchored: Bool { get }","comment":"A Boolean that indicates whether the entity is anchored.  The value of this property is `true` if the entity is anchored in a scene. An entity that isn’t anchored becomes inactive (``Entity\/isActive`` returns `false`), meaning RealityKit doesn’t render or simulate it."},{"name":"ambientAudio","complete":"@MainActor var ambientAudio: AmbientAudioComponent? { get set }","type":"AmbientAudioComponent","comment":"The component that configures the ambient rendering of sounds from this entity."},{"complete":"@MainActor var bindableValues: BindableValuesReference { get set }","name":"bindableValues","type":"BindableValuesReference"},{"type":"String","name":"accessibilityLabel","comment":"A succinct label that identifies the purpose of the image.  The default value for this property is `false`.  For entities with ``Entity\/isAccessibilityElement`` set to <doc:\/\/com.apple.documentation\/documentation\/swift\/true>, iOS uses this string to provide information to users of assistive technologies like VoiceOver. Set this property to a name or short description that accurately describes the entity. If you wish to provide additional information or a longer description of the entity, you can use ``Entity\/accessibilityDescription``.","complete":"@MainActor var accessibilityLabel: String? { get set }"},{"name":"hashValue","complete":"nonisolated var hashValue: Int { get }","type":"Int","comment":"The hash value.  Hash values are not guaranteed to be equal across different executions of your program. Do not save hash values to use during a future execution.  - Important: `hashValue` is deprecated as a `Hashable` requirement. To   conform to `Hashable`, implement the `hash(into:)` requirement instead.   The compiler provides an implementation for `hashValue` for you."},{"complete":"@MainActor var children: Entity.ChildCollection { get set }","type":"Entity.ChildCollection","name":"children","comment":"The child entities that the entity manages.  An entity can have any number of child entities.  Use the ``HasHierarchy\/addChild(_:preservingWorldTransform:)`` method to add a child to an entity. Use the ``HasHierarchy\/removeChild(_:preservingWorldTransform:)`` method to remove one from an entity. These methods automatically update the ``HasHierarchy\/parent`` properties of the child entities."},{"complete":"@MainActor var scale: SIMD3<Float> { get set }","type":"SIMD3<Float>","name":"scale","comment":"The scale of the entity relative to its parent.  This value is the entity’s scale relative to its parent. To get the actual scale of the entity in the scene, use ``HasTransform\/scale(relativeTo:)``, passing `nil` as the reference entity.  This is the same as the ``Transform\/scale`` value on the ``HasTransform\/transform``."},{"name":"name","type":"String","comment":"The name of the entity.  You can find an entity by name in a scene by calling the scene’s ``Scene\/findEntity(named:)`` method. Or you can recursively search among the children of a given entity by calling the entity’s ``Entity\/findEntity(named:)`` method.  Entity names are not guaranteed to be unique. When you search by name, these methods return the first entity encountered with the given name.","complete":"@MainActor var name: String { get set }"},{"name":"synchronization","type":"SynchronizationComponent","complete":"@MainActor var synchronization: SynchronizationComponent? { get set }","comment":"The entity’s synchronization component."},{"name":"defaultAnimationClock","type":"CMClockOrTimebase","comment":"Returns the default animation clock for this entity.","complete":"@MainActor var defaultAnimationClock: CMClockOrTimebase { get set }"},{"complete":"@MainActor var anchor: (HasAnchoring)? { get }","type":"(HasAnchoring)","comment":"The nearest ancestor entity that can act as an anchor.  This property returns `nil` if no ancestor can act as an anchor. An entity can act as an anchor if it adopts the ``HasAnchoring`` protocol. Just because an ancestor can be anchored doesn’t mean that it is. Inspect the ``Entity\/isAnchored`` property to see if an entity (or one of its ancestors) is anchored.","name":"anchor"},{"comment":"The component that configures the spatial rendering of sounds from this entity.","complete":"@MainActor var spatialAudio: SpatialAudioComponent? { get set }","type":"SpatialAudioComponent","name":"spatialAudio"},{"complete":"@MainActor var isAccessibilityElement: Bool { get set }","comment":"A Boolean value indicating whether the receiver is an accessibility element that an assistive application can access.","name":"isAccessibilityElement","type":"Bool"},{"complete":"@MainActor var components: Entity.ComponentSet { get set }","comment":"All the components stored on the entity.  You can only store one component of a given type on an entity.","type":"Entity.ComponentSet","name":"components"},{"complete":"@MainActor var isActive: Bool { get }","type":"Bool","comment":"A Boolean that indicates whether the entity is active.  The value of this property is `true` if the entity is anchored in a scene, and it and all of its ancestors are enabled (``Entity\/isEnabled`` is set to `true`). RealityKit doesn’t simulate or render inactive entities.","name":"isActive"},{"comment":"The stable identity of the entity associated with this instance.","name":"id","type":"UInt64","complete":"@MainActor var id: UInt64 { get }"},{"type":"Bool","comment":"A Boolean that indicates whether the calling process owns the entity.  The calling process owns the entity if the value is `true`.","complete":"@MainActor var isOwner: Bool { get }","name":"isOwner"},{"complete":"@MainActor var accessibilityDescription: String? { get set }","comment":"A longer description of the entity for use by assistive technologies.","name":"accessibilityDescription","type":"String"},{"comment":"The list of animations associated with the entity.  When you import an entity from a file, for example by using the ``Entity\/load(named:in:)`` method, the entity might contain associated animations. Any that RealityKit supports appear in the ``Entity\/availableAnimations`` array.  To play a particular animation resource from the list, call the ``Entity\/playAnimation(_:transitionDuration:startsPaused:)`` method. Alternatively, to play all animations with a given name, call the `playAnimation(named:transitionDuration:startsPaused:)` method instead.","complete":"@MainActor var availableAnimations: [AnimationResource] { get }","name":"availableAnimations","type":"[AnimationResource]"},{"complete":"@MainActor var scene: Scene? { get }","type":"Scene","comment":"The scene that owns the entity.  An entity belongs to a scene if the entity is part of a hierarchy that’s rooted in the scene’s ``Scene\/anchors`` collection.  The value of the property is `nil` if the entity isn’t currently attached to any scene.","name":"scene"},{"comment":"The rotation of the entity relative to its parent.  This value is the entity’s rotation relative to its parent. To get the world-space orientation of the entity, use ``HasTransform\/orientation(relativeTo:)``, passing `nil` as the reference entity.  This is the same as the ``Transform\/rotation`` value on the ``HasTransform\/transform``.","type":"simd_quatf","complete":"@MainActor var orientation: simd_quatf { get set }","name":"orientation"},{"comment":"The character controller state for  the entity.","name":"characterControllerState","type":"CharacterControllerStateComponent","complete":"@MainActor var characterControllerState: CharacterControllerStateComponent? { get set }"},{"type":"String","comment":"A human readable description of the entity.","name":"debugDescription","complete":"@MainActor var debugDescription: String { get }"},{"comment":"A Boolean that you set to enable or disable the entity and its descendants.  Set this value to `true` to enable the entity. Unless an ancestor is disabled, the entity and all of its enabled descendants, up to the first that’s disabled, report ``Entity\/isEnabledInHierarchy`` of `true`. If an ancestor is disabled, they all report `false`. The state of ``Entity\/isActive`` for enabled entities is `true` if they are anchored, or `false` otherwise.  If you disable an entity, it and all of its descendants become both disabled (``Entity\/isEnabledInHierarchy`` returns `false`) and inactive (``Entity\/isActive`` returns `false`), regardless of any other state.  When an entity is disabled, it's no longer visible in your scene. However, the entity is still included in an ``RealityKit\/EntityQuery``.","type":"Bool","name":"isEnabled","complete":"@MainActor var isEnabled: Bool { get set }"},{"name":"parent","complete":"@MainActor var parent: Entity? { get }","type":"Entity","comment":"The parent entity.  An entity has at most one parent entity. If an entity isn’t part of a hierarchy, or if it is a root entity, the ``HasHierarchy\/parent`` property is `nil`.  Use the ``HasHierarchy\/setParent(_:preservingWorldTransform:)`` method to change an entity’s parent. Use the ``HasHierarchy\/removeFromParent(preservingWorldTransform:)`` method to remove the parent. These methods automatically update the corresponding ``HasHierarchy\/children`` collections of the new and old parent."},{"name":"characterController","type":"CharacterControllerComponent","comment":"The character controller component for the entity.","complete":"@MainActor var characterController: CharacterControllerComponent? { get set }"},{"type":"Bool","complete":"@MainActor var isEnabledInHierarchy: Bool { get }","name":"isEnabledInHierarchy","comment":"A Boolean that indicates whether the entity and all of its ancestors are enabled.  The value of this property is `true` if the entity and all of its ancestors are enabled, regardless of anchor state."},{"type":"Entity.ParameterSet","name":"parameters","complete":"@MainActor var parameters: Entity.ParameterSet { get set }","comment":"Represents a reference to the parameters for a particular entity."},{"complete":"@MainActor var position: SIMD3<Float> { get set }","comment":"The position of the entity relative to its parent.  This value is the entity’s position relative to its parent. To get the world-space position of the entity in the scene, use ``HasTransform\/position(relativeTo:)``, passing `nil` as the reference entity.  This is the same as the ``Transform\/translation`` value on the ``HasTransform\/transform``.","name":"position","type":"SIMD3<Float>"},{"complete":"@MainActor var channelAudio: ChannelAudioComponent? { get set }","comment":"The component that configures the channel-based rendering of sounds from this entity.","name":"channelAudio","type":"ChannelAudioComponent"}],"comment":"An element of a RealityKit scene to which you attach components that provide appearance and behavior characteristics for the entity.  You create and configure entities to embody objects that you want to place in the real world in an AR app. You do this by adding ``Entity`` instances to the ``Scene`` instance associated with an ``ARView``.  RealityKit defines a few concrete subclasses of ``Entity`` that provide commonly used functionality. For example, you typically start by creating an instance of ``AnchorEntity`` to anchor your content, and add the anchor to a scene’s ``Scene\/anchors`` collection. You might then instantiate a ``ModelEntity`` to represent a physical object in the scene, and add that as a child entity to the anchor. You can also create custom entities, and add them either to an anchor, or as children of another entity.  ![Block diagram showing how entity hierarchies, composed of different kinds of entities, attach to a scene, which is itself a child of the AR view.](Entity-1)  You can load predefined entities or a hierarchy of entities from your app’s bundle, or from a file on disk, using the methods in <doc:stored-entities>. Alternatively, you can create entities programmatically.  Entities contain components (instances conforming to the ``Component`` protocol) that provide appearance and behaviors for the entity. For example, the ``Transform`` component contains the scale, rotation, and translation information needed to position an entity in space. You store components in the entity’s ``Entity\/components`` collection, which can hold exactly one of any component type. It makes sense to have only a single ``Transform`` component, one ``ModelComponent`` (specifying the visual appearance of the entity), and so on.  ![Diagram showing the components present in the base entity class, as well as in the derived anchor entity and model entity classes.](Entity-2)  All entities inherit a few common components from the ``Entity`` base class: the ``Transform`` component for spatial positioning, and ``SynchronizationComponent``, which enables synchronization of the entity among networked peers. Specific types of entities define additional behaviors. For example, the model entity has components for visual appearance (``ModelComponent``), collision detection (``CollisionComponent``), and physics simulations (``PhysicsBodyComponent`` and ``PhysicsMotionComponent``)."},{"name":"ModelEntity","properties":[{"type":"ModelDebugOptionsComponent","name":"debugModel","complete":"@MainActor var debugModel: ModelDebugOptionsComponent? { get set }"},{"name":"modelDebugOptions","type":"ModelDebugOptionsComponent","comment":"Configures the debug visualization of this model.","complete":"@MainActor var modelDebugOptions: ModelDebugOptionsComponent? { get set }"},{"name":"physicsBody","type":"PhysicsBodyComponent","comment":"A component that is used for physics simulations of the model entity in accordance with the laws of Newtonian mechanics.","complete":"@MainActor var physicsBody: PhysicsBodyComponent? { get set }"},{"name":"jointTransforms","complete":"@MainActor var jointTransforms: [Transform] { get set }","comment":"The relative joint transforms of the model entity.  Call ``RealityKit\/BodyTrackedEntity\/jointNames`` to determine the name and order of the joints.  - Note: Active animations may override the joint transforms set using this property..","type":"[Transform]"},{"comment":"The model component for the entity.","name":"model","type":"ModelComponent","complete":"@MainActor var model: ModelComponent? { get set }"},{"name":"collision","type":"CollisionComponent","comment":"The collision component that gives the entity the ability to participate in collision simulations.","complete":"@MainActor var collision: CollisionComponent? { get set }"},{"name":"jointNames","comment":"The names of all the joints in the model entity.","type":"[String]","complete":"@MainActor var jointNames: [String] { get }"},{"comment":"The physics motion component used by physics simulations of the model entity.","type":"PhysicsMotionComponent","complete":"@MainActor var physicsMotion: PhysicsMotionComponent? { get set }","name":"physicsMotion"}],"comment":"A representation of a physical object that RealityKit renders and optionally simulates.  Use one or more model entities to place physical objects in a scene. In addition to the components they inherit from the ``Entity`` class, model entities have geometry, described by their ``ModelComponent``. Model entities acquire the model component by conforming to the ``HasModel`` protocol. You specify meshes and materials to control how a model entity appears.  ![Diagram showing the components present in the model entity.](ModelEntity-1)  Models respond to physics simulations because they conform to the ``HasPhysics`` protocol. You give them mass and other physical properties with a ``PhysicsBodyComponent`` instance, and then apply forces or impulses. The simulator uses a ``PhysicsMotionComponent`` to manage the linear and angular velocity of the object. Alternatively, you can selectively circumvent the simulation to control position and velocity yourself. Do this for a given model by setting its physics body ``PhysicsBodyComponent\/mode`` to ``PhysicsBodyMode\/kinematic``.  Models can also collide with one another, and with other entities that conform to the ``HasCollision`` protocol. The ``CollisionComponent`` provides parameters that let you manage which models collide with each other. It also lets you control the collision shape, which for performance reasons, is typically simpler than the visual geometry."},{"name":"PerspectiveCamera","properties":[{"comment":"A camera component for the perspective camera entity.","complete":"@MainActor var camera: PerspectiveCameraComponent { get set }","name":"camera","type":"PerspectiveCameraComponent"}],"comment":"A virtual camera that establishes the rendering perspective.  During an AR session, RealityKit automatically uses the device’s camera to define the perspective from which to render the scene. When rendering a scene outside of an AR session (with the view’s ``ARView\/cameraMode-swift.property`` property set to ``ARView\/CameraMode-swift.enum\/nonAR``), RealityKit uses a ``PerspectiveCamera`` instead. You can add a perspective camera anywhere in your scene to control the point of view. If you don't explicitly provide one, RealityKit creates a default camera for you."},{"comment":"An invisible 3D shape that detects when objects enter or exit a given region of space.  A trigger volume is an entity that can participate in collisions because it has a ``CollisionComponent``. You use a trigger volume as a sensor that indicates when another collision-capable entity, like a ``ModelEntity``, enters the region of space occupied by the trigger volume. You can use the generated ``CollisionEvents`` between the trigger volume and the other entity to trigger an action, like indicating to the user that a projectile hit its target.  ![Diagram showing the components present in the trigger volume entity.](TriggerVolume-1)  The trigger volume itself is very simple. It lacks any physical appearance, and doesn’t participate in physics simulations. This makes it very efficient for tasks that require only collision detection.","name":"TriggerVolume","properties":[{"type":"CollisionComponent","name":"collision","complete":"@MainActor var collision: CollisionComponent? { get set }","comment":"The collision component that gives the entity the ability to participate in collision simulations."}]}]
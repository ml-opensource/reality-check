[{"properties":[{"name":"label","comment":"A succinct label that identifies the entity, in a localized string key.","complete":"var label: LocalizedStringResource?","type":"LocalizedStringResource"},{"type":"[LocalizedStringResource]","complete":"var customActions: [LocalizedStringResource]","comment":"An array of custom actions supported by the entity, identified by their localized string key.","name":"customActions"},{"comment":"A Boolean value indicating whether the receiver is an accessibility entity that an assistive application can access.","complete":"var isAccessibilityElement: Bool","type":"Bool","name":"isAccessibilityElement"},{"complete":"var systemActions: AccessibilityComponent.SupportedActions","name":"systemActions","type":"AccessibilityComponent.SupportedActions","comment":"The set of supported accessibility actions."},{"name":"value","complete":"var value: LocalizedStringResource?","comment":"A localized string key that represents the current value of the entity.","type":"LocalizedStringResource"},{"type":"[AccessibilityComponent.CustomContent]","complete":"var customContent: [AccessibilityComponent.CustomContent]","comment":"An array of custom content objects that deliver accessibility information.  Use the Custom Content API to leverage assistive technologies to deliver complex data sets to users in measured portions when they need it.","name":"customContent"}],"name":"AccessibilityComponent"},{"comment":"Allows an entity to change the resolution of the resources it uses according to its relevance to the user.","properties":[{"name":"pixelsPerMeter","type":"Float","complete":"var pixelsPerMeter: Float { get }"}],"name":"AdaptiveResolutionComponent"},{"name":"AmbientAudioComponent","comment":"Configure ambient rendering of sounds from an entity.  Ambient audio sources emit each channel of an audio resource from an angle projected from the entity, without reverberation. Ambient audio sources take into account the relative orientation of the source and the listener. Position is not taken into account; the channels do not get louder as the user moves toward them.  The audio resource's front channels (e.g., mono, center) are projected into the entity's -Z direction, with the rear channels projected into +Z. The left channels are laid out in -X and the right channels are laid out in +X.  ```swift let entity = Entity() let resource = try AudioFileResource.load(named: \"MyAudioFile\") entity.ambientAudio = AmbientAudioComponent() entity.playAudio(resource) ```  The `AmbientAudioComponent` allows you to set the overall level of all sounds played from the entity with the `gain` property, in relative Decibels, in the range `-.infinity ... .zero` where `-infinity` is silent and `.zero` is nominal.  ```swift entity.ambientAudio?.gain = -10 ```  Ambient audio sources are well suited to play back multichannel content which captures the acoustics of its originating environment in the recording process (e.g., multichannel field recordings of outdoor environments).","properties":[{"complete":"var gain: Audio.Decibel","comment":"The overall level for all sounds emitted from an entity. In relative Decibels, in the range  `-.infinity ... .zero` where `.zero` is the default.","name":"gain","type":"Audio.Decibel"},{"complete":"var hashValue: Int { get }","comment":"The hash value.  Hash values are not guaranteed to be equal across different executions of your program. Do not save hash values to use during a future execution.  - Important: `hashValue` is deprecated as a `Hashable` requirement. To   conform to `Hashable`, implement the `hash(into:)` requirement instead.   The compiler provides an implementation for `hashValue` for you.","type":"Int","name":"hashValue"}]},{"name":"AnchoringComponent","properties":[{"type":"AnchoringComponent.TrackingMode","complete":"var trackingMode: AnchoringComponent.TrackingMode { get set }","name":"trackingMode"},{"name":"target","type":"AnchoringComponent.Target","comment":"The kind of real world object to which the anchor entity should anchor.","complete":"let target: AnchoringComponent.Target"}],"comment":"A description of how virtual content can be anchored to the real world."},{"name":"AudioMixGroupsComponent","properties":[{"complete":"var hashValue: Int { get }","name":"hashValue","type":"Int","comment":"The hash value.  Hash values are not guaranteed to be equal across different executions of your program. Do not save hash values to use during a future execution.  - Important: `hashValue` is deprecated as a `Hashable` requirement. To   conform to `Hashable`, implement the `hash(into:)` requirement instead.   The compiler provides an implementation for `hashValue` for you."}]},{"properties":[{"comment":"The hash value.  Hash values are not guaranteed to be equal across different executions of your program. Do not save hash values to use during a future execution.  - Important: `hashValue` is deprecated as a `Hashable` requirement. To   conform to `Hashable`, implement the `hash(into:)` requirement instead.   The compiler provides an implementation for `hashValue` for you.","complete":"var hashValue: Int { get }","name":"hashValue","type":"Int"},{"comment":"The overall level for all sounds emitted from an entity. In relative Decibels, in the range  `-.infinity ... .zero` where `.zero` is the default.","type":"Audio.Decibel","name":"gain","complete":"var gain: Audio.Decibel"}],"comment":"Configure channel-based rendering of sounds from an entity.  Channel audio sources route the audio resource's channels directly to the device's output without any spatialization or reverberation applied. Neither the position nor orientation of the entity is taken into consideration for channel rendering. For example, the left channel will always be heard from the left, and the right channel will always be heard from the right, regardless of where the user is oriented.  The channels of multichannel audio resources are panned according to their channel layout, including rear channels.  ```swift let entity = Entity() let resource = try AudioFileResource.load(named: \"MyAudioFile\") entity.channelAudio = ChannelAudioComponent() entity.playAudio(resource) ```  The `ChannelAudioComponent` allows you to set the overall level of all sounds played from the entity with the `gain` property, in relative Decibels, in the range `-.infinity ... .zero` where `-infinity` is silent and `.zero` is nominal.  ```swift entity.channelAudio?.gain = -10 ```  Channel audio sources are well suited to play back sounds not associated with any visual elements in a scene.","name":"ChannelAudioComponent"},{"name":"CharacterControllerComponent","properties":[{"complete":"var collisionFilter: CollisionFilter","type":"CollisionFilter","name":"collisionFilter","comment":"The character's collision filter.  For more information on using collision filters, see <doc:\/\/com.apple.documentation\/realitykit\/controlling-entity-collisions-in-realitykit\/>."},{"name":"skinWidth","complete":"var skinWidth: Float","type":"Float","comment":"An added tolerance around the character capsule.  A small skin, known as the *contact offset*, is maintained around the controller's volume to avoid rounding and precision issues with collision detection. Specify this value relative to the entity's coordinate system."},{"name":"upVector","type":"SIMD3<Float>","complete":"var upVector: SIMD3<Float>","comment":"Y axis direction relative to the physics origin.  Rotates the object so that the vertical height is along the up vector. Vector must be normalized and specified in *physics space*, the coordinate system of the physics simulation."},{"complete":"var height: Float","type":"Float","name":"height","comment":"The capsule height.  The capsule height includes radii and should be specified the entity's coordinate system."},{"name":"slopeLimit","complete":"var slopeLimit: Float","comment":"The slope limit expressed as a limit angle in radians.  This value represents the maximum slope that the character can move over. RealityKit applies this value to characters that are walking on static objects, but not when walking on kinematic or dynamic objects.  Changing this value after the CharacterControllerComponent has been created and added to Entity has no effect.","type":"Float"},{"comment":"The maximum obstacle height that the controller can move over.  Specify this value relative to the entity's coordinate system.  Changing this value after the CharacterControllerComponent has been created and added to Entity has no effect.","type":"Float","name":"stepLimit","complete":"var stepLimit: Float"},{"complete":"var radius: Float","type":"Float","name":"radius","comment":"The capsule radius.  Specify this value in the entity's coordinate system."}],"comment":"A component that manages character movement.  To use a character controller, add a ``CharacterControllerComponent`` and a ``CharacterControllerStateComponent`` to your entity to make it a character entity. Character entities can *move* to new locations in space, which happens over a period of time based on how you've configured the character controller component, and also *teleport*, which moves the charcter to the new location instantaneously.  - Note: PhysicsBodyComponent and CollisionComponent can not exist on the same Entity that contains         a CharacterControllerComponent and are therefore inactivated."},{"comment":"An object that maintains state for a character controller.  Add this component to an entity, this along with ``CharacterControllerComponent``, to use the entity as a character that moves and animates.","name":"CharacterControllerStateComponent","properties":[{"type":"Bool","complete":"let isOnGround: Bool","comment":"True if character controller is grounded, otherwise false.","name":"isOnGround"},{"type":"SIMD3<Float>","name":"velocity","comment":"The linear speed relative to the phyics origin. In physics space.","complete":"let velocity: SIMD3<Float>"}]},{"comment":"A component that gives an entity the ability to collide with other entities that also have collision components.  This component holds the entity's data related to participating in the scene's physics simulation. It is also used to calculate collision queries, raycasts, and convex shape casts. Entities can participate in the scene simulation in two different modes: as a *rigid body* or as a *trigger*.  A rigid body fully participates in the collision simulation. It affects the velocity and direction of entities it collides. If configured with a rigid body ``RealityKit\/PhysicsBodyComponent\/mode`` of ``RealityKit\/PhysicsBodyMode\/dynamic``, it's own velocity and direction can be affected by other rigid body entities. A trigger entity doesn't have any impact on the rigid bodies in the scene, but can trigger code or Reality Composer behaviors when a rigid body enity overlaps it.  Note the following when considering applying a non-uniform scale to an entity: - Non-uniform scaling is applicable only to box, convex mesh and triangle mesh collision shapes. - Non-uniform scaling is not supported for all other types of collision shapes. In this case the scale.x value is duplicated to the scale's y and z components as well to force scale uniformity based on the x component. - If the entity has a non-uniform scale assigned to its transform then that entity should not have any descendants assigned that contain rotations in their transforms. A good rule of thumb is to assign the non-uniform scale to the entity that has the collision shape, and avoid adding children below that entity.  Turn an entity into a trigger by adding a ``RealityKit\/CollisionComponent`` to it and setting its ``RealityKit\/CollisionComponent\/mode-swift.property`` to ``RealityKit\/CollisionComponent\/Mode-swift.enum\/trigger``.  Turn an entity into a _rigd body_ by adding a  ``RealityKit\/PhysicsBodyComponent`` to the entity in addition to a ``RealityKit\/CollisionComponent``.  The ``PhysicsBodyComponent`` defines the physical properties of the entity, such as its mass and collision shape.  The `filter` property defines the entity's collision filter, which determines which other objects the entity collides with. For more information, see <doc:controlling-entity-collisions-in-realitykit>.  - Note: If an entity has a ``RealityKit\/PhysicsBodyComponent``, the  collision component's mode is ignored. An entity can be a rigid body, or a trigger, but not both at the same time.","properties":[{"type":"CollisionComponent.CollisionOptions","complete":"var collisionOptions: CollisionComponent.CollisionOptions { get set }","name":"collisionOptions"},{"complete":"var shapes: [ShapeResource]","comment":"A collection of shape resources that collectively represent the outer dimensions of an entity for the purposes of collision detection.","name":"shapes","type":"[ShapeResource]"},{"type":"CollisionComponent.Mode","name":"mode","comment":"The collision mode.","complete":"var mode: CollisionComponent.Mode"},{"type":"CollisionFilter","complete":"var filter: CollisionFilter","comment":"The collision filter used to segregate entities into different collision groups.","name":"filter"},{"name":"isStatic","type":"Bool","complete":"var isStatic: Bool { get set }","comment":"A Boolean value that indicates whether the collider is static.  When an object is static the physics engine recognizes that the object isn't moving, which typically improves performance."}],"name":"CollisionComponent"},{"properties":[{"name":"castsShadow","comment":"If true, the entity will cast a shadow","complete":"var castsShadow: Bool","type":"Bool"}],"name":"GroundingShadowComponent"},{"comment":"A component that applies a standard highlight effect when someone focuses an entity.   - Note: A `CollisionComponent` is required for the ``Entity`` to be part of hit-testing.","properties":[],"name":"HoverEffectComponent"},{"properties":[{"complete":"var intensityExponent: Float","type":"Float","comment":"The intensity value of the probe An intensityExponent of 0 means using the diffuse\/specular intensities as-is Otherwise the intensity is multiplied by 2^intensityExponent","name":"intensityExponent"},{"type":"ImageBasedLightComponent.Source","comment":"Image(s) of the lighting environment","complete":"var source: ImageBasedLightComponent.Source","name":"source"},{"complete":"var inheritsRotation: Bool","type":"Bool","name":"inheritsRotation","comment":"Whether the IBL inherit the rotation of the Entity"}],"name":"ImageBasedLightComponent"},{"properties":[{"name":"imageBasedLight","complete":"var imageBasedLight: Entity","type":"Entity"}],"name":"ImageBasedLightReceiverComponent"},{"properties":[{"name":"isEnabled","type":"Bool","complete":"var isEnabled: Bool","comment":"Whether the component's entity is enabled for input."},{"name":"allowedInputTypes","complete":"var allowedInputTypes: InputTargetComponent.InputType","type":"InputTargetComponent.InputType","comment":"The set of input types this component's entity can receive."}],"name":"InputTargetComponent","comment":"A component that gives an entity the ability to receive system input.  This component should be added to an entity to inform the system that it should be treated as a target for input handling. It can be customized to require only specific forms of input like direct or indirect interactions. By default the component is configured to handle all forms of input on the system.  The hit testing shape that defines the entity's interactive entity is defined by the `CollisionComponent`. To configure an entity for input but avoid any sort of physics-related processing, add an `InputTargetComponent` and `CollisionComponent`, but disable the `CollisionComponent` for collision detection, for example:  ``` \/\/ Enable the entity for input. myEntity.components.set(InputTargetComponent())  \/\/ Create a collision component with an empty group and mask. var collision = CollisionComponent(shapes: [.generateSphere(radius: 0.1)]) collision.filter = CollisionFilter(group: [], mask: []) myEntity.components.set(collision) ```  `InputTargetComponent` behaves hierarchically, so if it is added to an entity that has descendants with `CollisionComponent`s, those shapes will be used for input handling. The `isEnabled` flag can be used to override this behavior by adding the `InputTargetComponent` to a descendant and setting `isEnabled` to false.  `InputTargetComponent`'s `allowedInputTypes` property allows the entity to only receive the provided types of input. This property also propagates down the hierarchy, but if a descendant also has an `InputTargetComponent` defined, its `allowedInputTypes` property overrides the value provided by the ancestor."},{"comment":"A collection of resources that create the visual appearance of an entity.","name":"ModelComponent","properties":[{"name":"mesh","comment":"The mesh that defines the shape of the entity.  For more information, see ``RealityKit\/MeshResource``","type":"MeshResource","complete":"var mesh: MeshResource"},{"name":"materials","complete":"var materials: [Material]","comment":"The materials used by the model.  Each ``RealityKit\/MeshResource`` requires a set of materials. An entity that has no materials renders using a pink, striped material.  To determine the number of  materials a model entity requires , use `MeshResource.expectedMaterialCount`","type":"[Material]"},{"comment":"A margin applied to an entity’s bounding box that determines object visibility.  When determining which entities are currently visible, RealityKit tests each entity’s bounding box to see if it overlaps with the camera’s field of view (also known as the camera’s _frustum_). For efficiency, entities with a bounding box that don’t overlap the camera’s frustum aren’t rendered. Use this property to prevent RealityKit from incorrectly culling entities that use a ``CustomMaterial`` with a geometry modifier that moves vertices outside of the entity’s bounding box.  RealityKit adds the value of `boundsMargin` to the bounding box before determining which entities are visible.","type":"Float","name":"boundsMargin","complete":"var boundsMargin: Float { get set }"}]},{"properties":[{"name":"visualizationMode","complete":"var visualizationMode: ModelDebugOptionsComponent.VisualizationMode { get }","comment":"The part of the rendering process to display as the entity’s surface texture.","type":"ModelDebugOptionsComponent.VisualizationMode"}],"comment":"A component that changes how RealityKit renders its entity to help with debugging.  Attaching a `ModelDebugOptionsComponent` to a ``ModelEntity`` tells RealityKit to change the way it renders that entity based on a specified ``ModelDebugOptionsComponent\/visualizationMode-swift.property``. This component isolates individual parts of the rendering process, such as the entity’s transparency or roughness, and displays surface color to help identify visual anomalies.  To use this component, create a `ModelDebugOptionsComponent` and set its ``ModelDebugOptionsComponent\/visualizationMode-swift.property`` to the desired value. Then, set the component as the entity’s ``ModelEntity\/modelDebugOptions`` property:  ```swift if let robot = anchor.findEntity(named: \"Robot\") as? ModelEntity {     let component = ModelDebugOptionsComponent(visualizationMode: .normal)     robot.modelDebugOptions = component } ```  For more information on the visualization modes supported by `ModelDebugOptionsComponent`, see ``ModelDebugOptionsComponent\/VisualizationMode-swift.enum``.  ## Attach a Debug Component to an Entity  To attach a debug component to a particular entity, traverse the entity tree while passing the component to each child:  ```swift \/\/ Traverse the entity tree to attach a certain debug mode through components. func attachDebug(entity: Entity, debug: ModelDebugOptionsComponent) {     entity.components.set(debug)     for child in entity.children {         attachDebug(entity: child, debug: debug)     } } \/\/ Respond to a button or UI element. func debugLightingDiffuseButtonCallback() {     let debugComponent = ModelDebugOptionsComponent(visualizationMode: .lightingDiffuse)     attachDebug(entity: model, debug: debugComponent) } ```  ## Attach a Debug Component to a Trait  To attach a debug component based on a trait, traverse the entity tree while checking for ``HasModel`` adoption:  ```swift func attachDebug(entity: Entity, debug: ModelDebugOptionsComponent) {     if let model = entity as? ModelEntity {         model.visualizationMode = debug     }     for child in entity.children {         attachDebug(entity: child, debug: debug)     } } \/\/ Respond to a button or UI element. func debugLightingDiffuseButtonCallback() {     let debugComponent = ModelDebugOptionsComponent(visualizationMode: .lightingDiffuse)     attachDebug(entity: model, debug: debugComponent) } ```","name":"ModelDebugOptionsComponent"},{"name":"ModelSortGroupComponent","properties":[{"type":"Int32","name":"order","comment":"The draw order of the model relative to other models in its group. Lower value means the model draws earlier.","complete":"var order: Int32 { get set }"},{"name":"group","comment":"Group membership is strictly defined by having an identical group to other entities in the scene. This is not hierarchical; membership only applies to the entity which owns this component.","complete":"var group: ModelSortGroup { get set }","type":"ModelSortGroup"}],"comment":"A component that allows an entity's models to be rendered in an explicit order relative to the models of other entities in the same sort group. If this component is on an entity, then it must belong to a sort group."},{"name":"OpacityComponent","properties":[{"type":"Float","name":"opacity","comment":"The opacity value applied to the entity and its descendants.","complete":"var opacity: Float"}]},{"properties":[{"comment":"The shape of the region of space where the system spawns new particles. Defaults to plane.","type":"ParticleEmitterComponent.EmitterShape","name":"emitterShape","complete":"var emitterShape: ParticleEmitterComponent.EmitterShape"},{"name":"speedVariation","type":"Float","complete":"var speedVariation: Float","comment":"Defines a plus\/minus range (in meters per second) from which a value is randomly selected to offset particle speed."},{"comment":"Radius of the torus' emitter shape tube. Defaults to 0.25.","name":"torusInnerRadius","type":"Float","complete":"var torusInnerRadius: Float"},{"comment":"Particle attributes affecting the main particles of the base simulation.","type":"ParticleEmitterComponent.ParticleEmitter","name":"mainEmitter","complete":"var mainEmitter: ParticleEmitterComponent.ParticleEmitter"},{"name":"spawnSpreadFactorVariation","complete":"var spawnSpreadFactorVariation: Float","type":"Float","comment":"Defines a plus\/minus range from which a value is randomly selected to offset Spawn Spread Factor."},{"type":"SIMD3<Float>","name":"emissionDirection","comment":"The direction particles are emitted when birthDirection is set to World or Local. Defaults to (0.0, 1.0, 0.0).","complete":"var emissionDirection: SIMD3<Float>"},{"complete":"var spawnSpreadFactor: Float","comment":"Amount a spawned particle spreads away from its parent particle, works in conjunction with the spawn particle's `spreadingAngle`. Defaults to 0.","type":"Float","name":"spawnSpreadFactor"},{"type":"Float","name":"spawnVelocityFactor","comment":"How much of the parent particle's velocity to inherit. Defaults to 1.","complete":"var spawnVelocityFactor: Float"},{"complete":"var spawnInheritsParentColor: Bool","type":"Bool","comment":"Whether or not the spawnedEmitter's color should be overriden by the mainEmitter's color at the time of the spawning.","name":"spawnInheritsParentColor"},{"comment":"Controls particle simulation state: playing, paused or stopped. Defaults to `play`.","name":"simulationState","type":"ParticleEmitterComponent.SimulationState","complete":"var simulationState: ParticleEmitterComponent.SimulationState"},{"comment":"Number of particles to emit in a single burst. Defaults to 100.","name":"burstCount","complete":"var burstCount: Int","type":"Int"},{"type":"SIMD3<Float>","name":"emitterShapeSize","comment":"The emitter shape size in meters.","complete":"var emitterShapeSize: SIMD3<Float>"},{"name":"spawnOccasion","comment":"Determines when main particles emit spawn particles. Defaults to `onDeath`.","complete":"var spawnOccasion: ParticleEmitterComponent.SpawnOccasion","type":"ParticleEmitterComponent.SpawnOccasion"},{"comment":"The possible locations for newly spawned particles, relative to the emitter shape. Defaults to surface.","name":"birthLocation","type":"ParticleEmitterComponent.BirthLocation","complete":"var birthLocation: ParticleEmitterComponent.BirthLocation"},{"complete":"var burstCountVariation: Int","name":"burstCountVariation","comment":"Defines a plus\/minus range from which a value is randomly selected to offset `burstCount`.","type":"Int"},{"type":"ParticleEmitterComponent.ParticleEmitter","name":"spawnedEmitter","complete":"var spawnedEmitter: ParticleEmitterComponent.ParticleEmitter? { get set }","comment":"Attributes affecting secondary particles spawned from the main simulation."},{"complete":"var particlesInheritTransform: Bool","comment":"Determines if the entity's transformation also affects the particles.","name":"particlesInheritTransform","type":"Bool"},{"name":"radialAmount","comment":"Radial sweep angle for sphere, cylinder, cone, and torus emitter shapes. Defaults to 2 * pi.","complete":"var radialAmount: Float","type":"Float"},{"name":"birthDirection","type":"ParticleEmitterComponent.BirthDirection","complete":"var birthDirection: ParticleEmitterComponent.BirthDirection","comment":"The possible initial directions for newly spawned particles, relative to the emitter shape.Defaults to normal."},{"name":"speed","complete":"var speed: Float","type":"Float","comment":"The initial speed, in meters per second, for newly spawned particles. Defaults to 0.5."},{"name":"isEmitting","complete":"var isEmitting: Bool","type":"Bool","comment":"Disables\/enables particle emission, independent of `simulationState`. Existing particles will not be affected."},{"type":"ParticleEmitterComponent.SimulationSpace","comment":"Field Simulation Space, either local or global","name":"fieldSimulationSpace","complete":"var fieldSimulationSpace: ParticleEmitterComponent.SimulationSpace"}],"name":"ParticleEmitterComponent"},{"properties":[{"comment":"The camera’s total vertical field of view in degrees.  This property contains the entire vertifical field of view for the camera in degrees. The system automatically calculates the horizontal field of view from this value to fit the aspect ratio of the device’s screen.  This property defaults to `60` degrees.","name":"fieldOfViewInDegrees","type":"Float","complete":"var fieldOfViewInDegrees: Float"},{"name":"near","type":"Float","comment":"The minimum distance in meters from the camera that the camera can see.  The value defaults to 1 centimeter. Always use a value greater than `0` and less than the value of ``PerspectiveCameraComponent\/far``. The renderer clips any surface closer than the ``PerspectiveCameraComponent\/near`` point.","complete":"var near: Float"},{"type":"Float","name":"far","comment":"The maximum distance in meters from the camera that the camera can see.  The value defaults to infinity. Always use a value greater than the value of ``PerspectiveCameraComponent\/near``. The renderer clips any surface beyond the ``PerspectiveCameraComponent\/far`` point.","complete":"var far: Float"}],"name":"PerspectiveCameraComponent","comment":" In AR applications, the camera is automatically provided by the system. In non-AR scenarios, the camera needs to be set by the app. (If no camera is provided by the app, the system will use default camera.)"},{"comment":"A component that defines an entity’s behavior in physics body simulations.  To participate in a scene's physics simulation, an entity must have a ``RealityKit\/PhysicsBodyComponent`` and a ``RealityKit\/CollisionComponent``. If you need to move an entity that participates in the physics system, it also needs a ``RealityKit\/PhysicsMotionComponent``.  Add a physics body component to an entity by adopting the ``HasPhysicsBody`` protocol, which allows RealityKit’s physics simulation to compute behavior in response to forces acting upon the body, following basic rules of Newtonian mechanics.  Note the following when considering applying a non-uniform scale to an entity: - Non-uniform scaling is applicable only to box, convex mesh and triangle mesh collision shapes. - Non-uniform scaling is not supported for all other types of collision shapes. In this case the scale.x value is duplicated to the scale's y and z components as well to force scale uniformity based on the x component. - If the entity has a non-uniform scale assigned to its transform then that entity should not have any descendants assigned that contain rotations in their transforms. A good rule of thumb is to assign the non-uniform scale to the entity that has the collision shape, and avoid adding children below that entity.  - Note: Model entities have a physics body component by default.","name":"PhysicsBodyComponent","properties":[{"name":"isContinuousCollisionDetectionEnabled","complete":"var isContinuousCollisionDetectionEnabled: Bool","comment":"A Boolean that controls whether the physics simulation performs continuous collision detection.  Set the value to `true` to perform continuous collision detection. The value is `false` by default, indicating the simulation should apply discrete collision detection.  Discrete collision detection considers only the position of a body once per rendered frame, or about every 16 milliseconds at 60 frames per second. Continuous collision detection considers the position of the body throughout the frame interval. The latter is more computationally expensive, but can help to avoid missing a collision for a quickly moving object, like a projectile.","type":"Bool"},{"comment":"The physics body’s mass properties, like inertia and center of mass.  By default, the mass properties value is ``PhysicsMassProperties\/default``, which matches the properties of a unit sphere with mass of 1 kilogram.","name":"massProperties","complete":"var massProperties: PhysicsMassProperties","type":"PhysicsMassProperties"},{"name":"material","comment":"The physics body’s material properties, like friction.  By default, the body’s material resource is set to ``PhysicsMaterialResource\/default``, which provides a modest amount of friction and restitution (bounciness).","complete":"var material: PhysicsMaterialResource","type":"PhysicsMaterialResource"},{"type":"(x: Bool, y: Bool, z: Bool)","complete":"var isTranslationLocked: (x: Bool, y: Bool, z: Bool)","name":"isTranslationLocked","comment":"A tuple of Boolean values that you use to lock the position of the physics body along any of the three axes.  You can restrict movement of the body along one or more axes by setting the corresponding item in the tuple to `true`. For example, if you set the `x` and the `z` items in the tuple to `true`, then the body can move only along the y-axis. By default, movement isn’t restricted."},{"name":"linearDamping","comment":"The value that controls how fast a dynamic rigid body's translation motion approaches the zero rest state.  - Important: The damping value must be non-negative.","complete":"var linearDamping: Float { get set }","type":"Float"},{"type":"Float","comment":"The value that controls how fast a dynamic rigid body's rotational motion approaches the zero rest state.  - Important: The damping value must be non-negative.","name":"angularDamping","complete":"var angularDamping: Float { get set }"},{"type":"Bool","name":"isAffectedByGravity","complete":"var isAffectedByGravity: Bool { get set }","comment":"A Boolean value that indicates whether gravity acts on dynamic rigid bodies."},{"comment":"A tuple of Boolean values that you use to lock rotation of the physics body around any of the three axes.  For any one of the three Booleans in the tuple that you set to `true`, rotation is restricted on the axis represented by that item. For example, if you set the `x` item to true, then the body can’t rotate around the x-axis. By default, rotation isn’t restricted.","type":"(x: Bool, y: Bool, z: Bool)","name":"isRotationLocked","complete":"var isRotationLocked: (x: Bool, y: Bool, z: Bool)"},{"comment":"The physics body’s mode, indicating how or if it moves.  By default, this value is set to ``PhysicsBodyMode\/dynamic``, meaning the body responds to forces.","name":"mode","complete":"var mode: PhysicsBodyMode","type":"PhysicsBodyMode"}]},{"name":"PhysicsMotionComponent","properties":[{"complete":"var linearVelocity: SIMD3<Float>","type":"SIMD3<Float>","comment":"The linear velocity of the body in the physics simulation.","name":"linearVelocity"},{"complete":"var angularVelocity: SIMD3<Float>","comment":"The angular velocity of the body around the center of mass.","name":"angularVelocity","type":"SIMD3<Float>"}],"comment":"A component that controls the motion of the body in physics simulations.  You specify velocities in the coordinate space of the physics simulation defined by ``ARView\/PhysicsSimulationComponent.nearestSimulationEntity``.  The behavior of an entity with a physics motion component depends on the entity’s ``PhysicsBodyComponent\/mode`` setting:  - term ``PhysicsBodyMode\/static``: The physics simulation ignores the velocities. The entity doesn’t move. - term ``PhysicsBodyMode\/kinematic``: The physics simulation moves the body according to the values you set for ``PhysicsMotionComponent\/angularVelocity`` and ``PhysicsMotionComponent\/linearVelocity``. - term ``PhysicsBodyMode\/dynamic``: The physics simulation overwrites the velocity values based on simulation, and ignores any values that you write."},{"comment":"A component that controls localized physics simulations.  To use a localized physics simulation add a ``PhysicsSimulationComponent`` to the desired root entity. Use the component to set custom physics simulation properties such as ``gravity`` and ``collisionOptions`` specific to the physics simulation.","properties":[{"type":"SIMD3<Float>","complete":"var gravity: SIMD3<Float>","comment":"The gravity for the simulation relative to the simulation entity.  The value stored in this property is the gravitational acceleration applied to dynamic physics body entities every frame along the negative world Y axis. The default value is `-9.81` meters per second squared.","name":"gravity"},{"type":"CMClockOrTimebase","name":"clock","comment":"A custom clock which drives the physics simulation, defaults to the engine clock.","complete":"var clock: CMClockOrTimebase { get set }"},{"type":"PhysicsSimulationComponent.CollisionOptions","comment":"Options for kinematic collision reporting.","complete":"var collisionOptions: PhysicsSimulationComponent.CollisionOptions","name":"collisionOptions"}],"name":"PhysicsSimulationComponent"},{"name":"PortalComponent","properties":[{"name":"targetEntity","complete":"var targetEntity: Entity? { get set }","type":"Entity","comment":"The target entity representing the world that the portal is targeting. When the target entity is valid and has a WorldComponent, the portal will render in its contents the target entity and its entity tree."},{"complete":"var clippingPlane: PortalComponent.ClippingPlane?","type":"PortalComponent.ClippingPlane","name":"clippingPlane","comment":"The clipping plane of the portal, defined in the entity's local coordinates.  If defined, the portal will clip meshes inside the world, which are in front of the clipping plane."}]},{"name":"SceneUnderstandingComponent","comment":"A component that maps features of the physical environment.  Example features include faces and the shape of arbitrary regions.","properties":[{"complete":"var origin: SceneUnderstandingComponent.Origin { get }","name":"origin","type":"SceneUnderstandingComponent.Origin","comment":"The origin which the component is created from"},{"name":"entityType","complete":"var entityType: SceneUnderstandingComponent.EntityType?","type":"SceneUnderstandingComponent.EntityType","comment":"The type of real-world object that the component models."}]},{"name":"SpatialAudioComponent","properties":[{"type":"Audio.Decibel","comment":"The level of the direct, unreverberated, signal emitted from an entity. In relative Decibels, in the range `-.infinity ... .zero` where `.zero` is the default.","complete":"var directLevel: Audio.Decibel","name":"directLevel"},{"type":"Audio.Decibel","complete":"var reverbLevel: Audio.Decibel","comment":"The level of reverberated signal emitted from an entity. In relative Decibels, in the range  `-.infinity ... .zero`, where `.zero` is the default.  Reducing this value will cause the sound to be more intimate. Reducing this value to `.-infinity` will cause the sounds to collapse into the head of the listener.","name":"reverbLevel"},{"name":"gain","type":"Audio.Decibel","comment":"The overall level for all sounds emitted from an entity. In relative Decibels, in the range  `-.infinity ... .zero` where `.zero` is the default.","complete":"var gain: Audio.Decibel"},{"type":"Int","complete":"var hashValue: Int { get }","comment":"The hash value.  Hash values are not guaranteed to be equal across different executions of your program. Do not save hash values to use during a future execution.  - Important: `hashValue` is deprecated as a `Hashable` requirement. To   conform to `Hashable`, implement the `hash(into:)` requirement instead.   The compiler provides an implementation for `hashValue` for you.","name":"hashValue"},{"comment":"The radiation pattern for sound emitted from an entity.  - Note: The `directivity` property cannot be updated dynamically, so you must set it before preparing or playing an         audio resource on an entity.","name":"directivity","type":"Audio.Directivity","complete":"var directivity: Audio.Directivity"}],"comment":"Configure how sounds are emitted from an entity into the user's environment.  The position and orientation of spatial audio sources are updated continuously and automatically by the audio system, so sounds always come from an entity wherever it goes and wherever it is pointing. Spatial audio sources have the user environment's acoustics applied to them so that they blend in naturally with it, and they are distance attenuated so they become quieter the further away they are from the user.  - Note: Spatial audio sources emit only a single channel (i.e., mono). If the format of the audio resource played on the entity is stereo or multichannel, all of its channels will be mixed down to a single channel before spatialization. To minimize any unwanted mixdown artifacts, use mono source material where possible.  RealityKit audio playback is spatial by default, so no additional configuration is necessary to opt into sophisticated spatial rendering.  ```swift let entity = Entity() let resource = try AudioFileResource.load(named: \"MyAudioFile\") entity.playAudio(resource) \/\/ Audio file is played spatially from entity ```  The `SpatialAudioComponent` allows you to further customize the playback characteristics of spatial audio sources. The `gain`, `directLevel`, and `reverbLevel` properties are in relative Decibels, in the range `-.infinity ... .zero`, where `-.infinity` is silent and `.zero` is nominal.  For example, you can adjust the overall level of all sounds played from the entity with the `gain` property.  ```swift entity.spatialAudio = SpatialAudioComponent(gain: -10) ```  You can reduce the amount of reverb applied to all sounds played from the entity with the `reverbLevel` property. Reducing this value will make the sounds less reverberant and more intimate. Setting `reverbLevel` to `-.infinity` will cause the sounds to collapse into the head of the listener.  ```swift entity.spatialAudio?.reverbLevel = -6 ```  The `gain`, `directLevel`, and `reverbLevel` properties can be updated dynamically, for example based on your app's state, or in the context of a Custom RealityKit System.  The `directivity` property allows you to configure the radiation pattern for sound emitted from the entity.  ```swift entity.spatialAudio?.directivity = .beam(focus: 0.5) ```  Spatial audio sources project sounds along their -Z axis. If a spatial audio source is co-located and co-oriented with visual content authored with a +Z-forward coordinate convention, you will want to rotate your spatial audio source 180º about the Y-axis.  ```swift let parent = Entity()  \/\/ Add model entity let model = try ModelEntity.load(named: \"PositiveZForward\") parent.addChild(model)  \/\/ Add audio source entity let audioSource = Entity() parent.addChild(audioSource)  \/\/ Orient audio source towards +Z audioSource.orientation = .init(angle: .pi, axis: [0, 1, 0]) ```  This is only a consideration if you have explicitly set a `directivity` other than the default `.beam(focus: .zero)`, which projects sound evenly for all frequencies in all directions."},{"name":"SynchronizationComponent","properties":[{"comment":"A Boolean that indicates whether the calling process owns the entity.","name":"isOwner","type":"Bool","complete":"var isOwner: Bool { get }"},{"comment":"A unique identifier of an entity within a network session.","type":"UInt64","complete":"var identifier: UInt64 { get }","name":"identifier"},{"name":"ownershipTransferMode","type":"SynchronizationComponent.OwnershipTransferMode","complete":"var ownershipTransferMode: SynchronizationComponent.OwnershipTransferMode","comment":"The entity’s transfer ownership mode.  By default, the transfer mode is ``SynchronizationComponent\/OwnershipTransferMode-swift.enum\/autoAccept``. You can set it to ``SynchronizationComponent\/OwnershipTransferMode-swift.enum\/manual`` to require explicit confirmation of the request by your app."}],"comment":"A component that synchronizes an entity between processes and networked applications.  An entity acquires a ``SynchronizationComponent`` instance by adopting the ``HasSynchronization`` protocol. All entities have this component because the ``Entity`` base class adopts the protocol."},{"properties":[{"name":"backgroundColor","type":"CGColor","complete":"var backgroundColor: CGColor?"},{"name":"size","type":"CGSize","complete":"var size: CGSize { get set }"},{"type":"Float","name":"cornerRadius","complete":"var cornerRadius: Float"},{"complete":"var text: AttributedString?","name":"text","type":"AttributedString"}],"name":"TextComponent"},{"comment":"A component that defines the scale, rotation, and translation of an entity.  An entity acquires a ``Transform`` component, as well as a set of methods for manipulating the transform, by adopting the ``HasTransform`` protocol. This is true for all entities, because the ``Entity`` base class adopts the protocol.","name":"Transform","properties":[{"name":"translation","type":"SIMD3<Float>","complete":"var translation: SIMD3<Float>","comment":"The position of the entity along the x, y, and z axes."},{"name":"rotation","complete":"var rotation: simd_quatf","comment":"The rotation of the entity specified as a unit quaternion.","type":"simd_quatf"},{"complete":"var matrix: float4x4 { get set }","comment":"The transform represented as a 4x4 matrix.  The ``Transform`` component can’t represent all transforms that a general 4x4 matrix can represent. Using a 4x4 matrix to set the transform is therefore a lossy event that might result in certain transformations, like shear, being dropped.","name":"matrix","type":"float4x4"},{"type":"Int","name":"hashValue","comment":"The hash value.  Hash values are not guaranteed to be equal across different executions of your program. Do not save hash values to use during a future execution.  - Important: `hashValue` is deprecated as a `Hashable` requirement. To   conform to `Hashable`, implement the `hash(into:)` requirement instead.   The compiler provides an implementation for `hashValue` for you.","complete":"var hashValue: Int { get }"},{"type":"SIMD3<Float>","complete":"var scale: SIMD3<Float>","comment":"The scaling factor applied to the entity.","name":"scale"}]},{"properties":[{"type":"SIMD2<Float>","complete":"var screenVideoDimension: SIMD2<Float> { get }","comment":"The current screen video dimension","name":"screenVideoDimension"},{"complete":"var playerScreenSize: SIMD2<Float> { get }","comment":"Represents the current video player screen entity size(Width and Height) in meters if defer transition to app, this will always return 1x1","name":"playerScreenSize","type":"SIMD2<Float>"},{"name":"avPlayer","complete":"var avPlayer: AVPlayer? { get }","type":"AVPlayer","comment":"Returns the avPlayer passed in to init(avPlayer: AVPlayer)"},{"type":"SIMD2<Float>","comment":"the current screen video dimension","complete":"var currentScreenVideoDimension: SIMD2<Float> { get }","name":"currentScreenVideoDimension"},{"name":"isPassthroughTintingEnabled","type":"Bool","complete":"var isPassthroughTintingEnabled: Bool"},{"complete":"var viewingMode: VideoPlaybackController.ViewingMode? { get }","name":"viewingMode","type":"VideoPlaybackController.ViewingMode"},{"type":"VideoPlaybackController.ViewingMode","name":"desiredViewingMode","complete":"var desiredViewingMode: VideoPlaybackController.ViewingMode"}],"name":"VideoPlayerComponent"},{"name":"WorldComponent","properties":[],"comment":"When set on an entity, a WorldComponent separates the entity and its subtree to be rendered as part of a diferent world, that is only visible through a portal.  Entities in a WorldComponent are rendered in a isolated lighting environment. To light entities in this environment, use an ImageBasedLightComponent placed within the entity subtree."}]
[
  {
    "name" : "AccessibilityComponent",
    "properties" : [
      {
        "comment" : "The Custom Content API is useful for delivering accessibility information from complex data sets to your users in measured portions. Using this API allows you to leverage assistive technologies to present only the accessible content your appâ€™s users need, when they need it.",
        "complete" : "var customContent: [AccessibilityComponent.CustomContent]",
        "name" : "customContent",
        "type" : "[AccessibilityComponent.CustomContent]"
      },
      {
        "comment" : "An array of custom actions supported by the entity, identified by their localized string key.",
        "complete" : "var customActions: [LocalizedStringResource]",
        "name" : "customActions",
        "type" : "[LocalizedStringResource]"
      },
      {
        "comment" : "A succinct label that identifies the entity, in a localized string key.",
        "complete" : "var label: LocalizedStringResource?",
        "name" : "label",
        "type" : "LocalizedStringResource"
      },
      {
        "comment" : "The set of supported accessibility actions.",
        "complete" : "var systemActions: AccessibilityComponent.SupportedActions",
        "name" : "systemActions",
        "type" : "AccessibilityComponent.SupportedActions"
      },
      {
        "comment" : "A localized string key that represents the current value of the entity.",
        "complete" : "var value: LocalizedStringResource?",
        "name" : "value",
        "type" : "LocalizedStringResource"
      },
      {
        "comment" : "A Boolean value indicating whether the receiver is an accessibility entity that an assistive application can access.",
        "complete" : "var isAccessibilityElement: Bool",
        "name" : "isAccessibilityElement",
        "type" : "Bool"
      }
    ]
  },
  {
    "comment" : "A description of how virtual content can be anchored to the real world.",
    "name" : "AnchoringComponent",
    "properties" : [
      {
        "comment" : "The kind of real world object to which the anchor entity should anchor.",
        "complete" : "let target: AnchoringComponent.Target",
        "name" : "target",
        "type" : "AnchoringComponent.Target"
      }
    ]
  },
  {
    "comment" : "A component that manages character movement.  To use a character controller, add a ``CharacterControllerComponent`` and a ``CharacterControllerStateComponent`` to your entity to make it a character entity. Character entities can *move* to new locations in space, which happens over a period of time based on how you've configured the character controller component, and also *teleport*, which moves the charcter to the new location instantaneously.",
    "name" : "CharacterControllerComponent",
    "properties" : [
      {
        "comment" : "The maximum obstacle height that the controller can move over.  Specify this value relative to the entity's coordinate system.",
        "complete" : "var stepLimit: Float",
        "name" : "stepLimit",
        "type" : "Float"
      },
      {
        "comment" : "The capsule radius.  Specify this value in the entity's coordinate system.",
        "complete" : "var radius: Float",
        "name" : "radius",
        "type" : "Float"
      },
      {
        "comment" : "The slope limit expressed as a limit angle in radians.  This value represents the maximum slope that the character can move over. RealityKit applies this value to characters that are walking on static objects, but not when walking on kinematic or dynamic objects.",
        "complete" : "var slopeLimit: Float",
        "name" : "slopeLimit",
        "type" : "Float"
      },
      {
        "comment" : "The character's collision filter.  For more information on using collision filters, see <doc:\/\/com.apple.documentation\/realitykit\/controlling-entity-collisions-in-realitykit\/>.",
        "complete" : "var collisionFilter: CollisionFilter",
        "name" : "collisionFilter",
        "type" : "CollisionFilter"
      },
      {
        "comment" : "The capsule height.  The capsule height includes radii and should be specified the entity's coordinate system.",
        "complete" : "var height: Float",
        "name" : "height",
        "type" : "Float"
      },
      {
        "comment" : "Y axis direction relative to the physics origin.  Rotates the object so that the vertical height is along the up vector. Vector must be normalized and specified in *physics space*, the coordinate system of the physics simulation.",
        "complete" : "var upVector: SIMD3<Float>",
        "name" : "upVector",
        "type" : "SIMD3<Float>"
      },
      {
        "comment" : "An added tolerance around the character capsule.  A small skin, known as the *contact offset*, is maintained around the controller's volume to avoid rounding and precision issues with collision detection. Specify this value relative to the entity's coordinate system.",
        "complete" : "var skinWidth: Float",
        "name" : "skinWidth",
        "type" : "Float"
      }
    ]
  },
  {
    "comment" : "An object that maintains state for a character controller.  Add this component to an entity, this along with ``CharacterControllerComponent``, to use the entity as a character that moves and animates.",
    "name" : "CharacterControllerStateComponent",
    "properties" : [
      {
        "comment" : "The linear speed relative to the phyics origin. In physics space.",
        "complete" : "let velocity: SIMD3<Float>",
        "name" : "velocity",
        "type" : "SIMD3<Float>"
      },
      {
        "comment" : "True if character controller is grounded, otherwise false.",
        "complete" : "let isOnGround: Bool",
        "name" : "isOnGround",
        "type" : "Bool"
      }
    ]
  },
  {
    "comment" : "A component that gives an entity the ability to collide with other entities that also have collision components.  This component holds the entity's data related to participating in the scene's physics simulation. It is also used to calculate collision queries, raycasts, and convex shape casts. Entities can participate in the scene simulation in two different modes: as a *rigid body* or as a *trigger*.  A rigid body fully participates in the collision simulation. It affects the velocity and direction of entities it collides. If configured with a rigid body ``RealityKit\/PhysicsBodyComponent\/mode`` of ``RealityKit\/PhysicsBodyMode\/dynamic``, it's own velocity and direction can be affected by other rigid body entities. A trigger entity doesn't have any impact on the rigid bodies in the scene, but can trigger code or Reality Composer behaviors when a rigid body enity overlaps it.  Turn an entity into a trigger by adding a ``RealityKit\/CollisionComponent`` to it and setting its ``RealityKit\/CollisionComponent\/mode-swift.property`` to ``RealityKit\/CollisionComponent\/Mode-swift.enum\/trigger``.  Turn an entity into a _rigd body_ by adding a  ``RealityKit\/PhysicsBodyComponent`` to the entity in addition to a ``RealityKit\/CollisionComponent``.  The ``PhysicsBodyComponent`` defines the physical properties of the entity, such as its mass and collision shape.  The `filter` property defines the entity's collision filter, which determines which other objects the entity collides with. For more information, see <doc:controlling-entity-collisions-in-realitykit>.  - Note: If an entity has a ``RealityKit\/PhysicsBodyComponent``, the  collision component's mode is ignored. An entity can be a rigid body, or a trigger, but not both at the same time.",
    "name" : "CollisionComponent",
    "properties" : [
      {
        "comment" : "The collision filter used to segregate entities into different collision groups.",
        "complete" : "var filter: CollisionFilter",
        "name" : "filter",
        "type" : "CollisionFilter"
      },
      {
        "comment" : "A collection of shape resources that collectively represent the outer dimensions of an entity for the purposes of collision detection.",
        "complete" : "var shapes: [ShapeResource]",
        "name" : "shapes",
        "type" : "[ShapeResource]"
      },
      {
        "comment" : "The collision mode.",
        "complete" : "var mode: CollisionComponent.Mode",
        "name" : "mode",
        "type" : "CollisionComponent.Mode"
      }
    ]
  },
  {
    "comment" : "A component that defines a directional light source.  A directional light shines in the entithy's forward direction (0, 0, -1). To orient a directional light, use `HasTransform.look(at:from:upVector:)`.  A directional light source can cast shadows. To enable shadows, create a ``RealityKit\/DirectionalLightComponent\/Shadow`` and assign it to `HasDirectionalLight.shadow`. To disable shadows set `HasDirectionalLight.shadow` to `nil`.",
    "name" : "DirectionalLightComponent",
    "properties" : [
      {
        "comment" : "A Boolean that you use to control whether the directional light operates as a proxy for a real-world light.  Set the value to `true` when you want the light to cast shadows on virtual content without illuminating anything in the scene. You can use this to create shadows on occlusion materials that accept dynamic lighting.",
        "complete" : "var isRealWorldProxy: Bool",
        "name" : "isRealWorldProxy",
        "type" : "Bool"
      },
      {
        "comment" : "The intensity of the directional light, measured in lumen per square meter.",
        "complete" : "var intensity: Float",
        "name" : "intensity",
        "type" : "Float"
      }
    ]
  },
  {
    "comment" : "A collection of resources that create the visual appearance of an entity.",
    "name" : "ModelComponent",
    "properties" : [
      {
        "comment" : "The mesh that defines the shape of the entity.  For more information, see ``RealityKit\/MeshResource``",
        "complete" : "var mesh: MeshResource",
        "name" : "mesh",
        "type" : "MeshResource"
      },
      {
        "comment" : "The materials used by the model.  Each ``RealityKit\/MeshResource`` requires a set of materials. An entity that has no materials renders using a pink, striped material.  To determine the number of  materials a model entity requires , use `MeshResource.expectedMaterialCount`",
        "complete" : "var materials: [Material]",
        "name" : "materials",
        "type" : "[Material]"
      },
      {
        "comment" : "A margin applied to an entityâ€™s bounding box that determines object visibility.  When determining which entities are currently visible, RealityKit tests each entityâ€™s bounding box to see if it overlaps with the cameraâ€™s field of view (also known as the cameraâ€™s _frustum_). For efficiency, entities with a bounding box that donâ€™t overlap the cameraâ€™s frustum arenâ€™t rendered. Use this property to prevent RealityKit from incorrectly culling entities that use a ``CustomMaterial`` with a geometry modifier that moves vertices outside of the entityâ€™s bounding box.  RealityKit adds the value of `boundsMargin` to the bounding box before determining which entities are visible.",
        "complete" : "var boundsMargin: Float { get set }",
        "name" : "boundsMargin",
        "type" : "Float"
      }
    ]
  },
  {
    "comment" : "A component that changes how RealityKit renders its entity to help with debugging.  Attaching a `ModelDebugOptionsComponent` to a ``ModelEntity`` tells RealityKit to change the way it renders that entity based on a specified ``ModelDebugOptionsComponent\/visualizationMode-swift.property``. This component isolates individual parts of the rendering process, such as the entityâ€™s transparency or roughness, and displays surface color to help identify visual anomalies.  To use this component, create a `ModelDebugOptionsComponent` and set its ``ModelDebugOptionsComponent\/visualizationMode-swift.property`` to the desired value. Then, set the component as the entityâ€™s ``ModelEntity\/modelDebugOptions`` property:  ```swift if let robot = anchor.findEntity(named: \"Robot\") as? ModelEntity {     let component = ModelDebugOptionsComponent(visualizationMode: .normal)     robot.modelDebugOptions = component } ```  For more information on the visualization modes supported by `ModelDebugOptionsComponent`, see ``ModelDebugOptionsComponent\/VisualizationMode-swift.enum``.  ## Attach a Debug Component to an Entity  To attach a debug component to a particular entity, traverse the entity tree while passing the component to each child:  ```swift \/\/ Traverse the entity tree to attach a certain debug mode through components. func attachDebug(entity: Entity, debug: ModelDebugOptionsComponent) {     entity.components.set(debug)     for child in entity.children {         attachDebug(entity: child, debug: debug)     } } \/\/ Respond to a button or UI element. func debugLightingDiffuseButtonCallback() {     let debugComponent = ModelDebugOptionsComponent(visualizationMode: .lightingDiffuse)     attachDebug(entity: model, debug: debugComponent) } ```  ## Attach a Debug Component to a Trait  To attach a debug component based on a trait, traverse the entity tree while checking for ``HasModel`` adoption:  ```swift func attachDebug(entity: Entity, debug: ModelDebugOptionsComponent) {     if let model = entity as? ModelEntity {         model.visualizationMode = debug     }     for child in entity.children {         attachDebug(entity: child, debug: debug)     } } \/\/ Respond to a button or UI element. func debugLightingDiffuseButtonCallback() {     let debugComponent = ModelDebugOptionsComponent(visualizationMode: .lightingDiffuse)     attachDebug(entity: model, debug: debugComponent) } ```",
    "name" : "ModelDebugOptionsComponent",
    "properties" : [
      {
        "comment" : "The part of the rendering process to display as the entityâ€™s surface texture.",
        "complete" : "var visualizationMode: ModelDebugOptionsComponent.VisualizationMode { get }",
        "name" : "visualizationMode",
        "type" : "ModelDebugOptionsComponent.VisualizationMode"
      }
    ]
  },
  {
    "comment" : " In AR applications, the camera is automatically provided by the system. In non-AR scenarios, the camera needs to be set by the app. (If no camera is provided by the app, the system will use default camera.)",
    "name" : "PerspectiveCameraComponent",
    "properties" : [
      {
        "comment" : "The minimum distance in meters from the camera that the camera can see.  The value defaults to 1 centimeter. Always use a value greater than `0` and less than the value of ``PerspectiveCameraComponent\/far``. The renderer clips any surface closer than the ``PerspectiveCameraComponent\/near`` point.",
        "complete" : "var near: Float",
        "name" : "near",
        "type" : "Float"
      },
      {
        "comment" : "The cameraâ€™s total vertical field of view in degrees.  This property contains the entire vertifical field of view for the camera in degrees. The system automatically calculates the horizontal field of view from this value to fit the aspect ratio of the deviceâ€™s screen.  This property defaults to `60` degrees.",
        "complete" : "var fieldOfViewInDegrees: Float",
        "name" : "fieldOfViewInDegrees",
        "type" : "Float"
      },
      {
        "comment" : "The maximum distance in meters from the camera that the camera can see.  The value defaults to infinity. Always use a value greater than the value of ``PerspectiveCameraComponent\/near``. The renderer clips any surface beyond the ``PerspectiveCameraComponent\/far`` point.",
        "complete" : "var far: Float",
        "name" : "far",
        "type" : "Float"
      }
    ]
  },
  {
    "comment" : "A component that defines an entityâ€™s behavior in physics body simulations.  To participate in a scene's physics simulation, an entity must have a ``RealityKit\/PhysicsBodyComponent`` and a ``RealityKit\/CollisionComponent``. If you need to move an entity that participates in the physics system, it also needs a ``RealityKit\/PhysicsMotionComponent``.  Add a physics body component to an entity by adopting the ``HasPhysicsBody`` protocol, which allows RealityKitâ€™s physics simulation to compute behavior in response to forces acting upon the body, following basic rules of Newtonian mechanics.  - Note: Model entities have a physics body component by default.",
    "name" : "PhysicsBodyComponent",
    "properties" : [
      {
        "comment" : "The physics bodyâ€™s mode, indicating how or if it moves.  By default, this value is set to ``PhysicsBodyMode\/dynamic``, meaning the body responds to forces.",
        "complete" : "var mode: PhysicsBodyMode",
        "name" : "mode",
        "type" : "PhysicsBodyMode"
      },
      {
        "comment" : "A Boolean that controls whether the physics simulation performs continuous collision detection.  Set the value to `true` to perform continuous collision detection. The value is `false` by default, indicating the simulation should apply discrete collision detection.  Discrete collision detection considers only the position of a body once per rendered frame, or about every 16 milliseconds at 60 frames per second. Continuous collision detection considers the position of the body throughout the frame interval. The latter is more computationally expensive, but can help to avoid missing a collision for a quickly moving object, like a projectile.",
        "complete" : "var isContinuousCollisionDetectionEnabled: Bool",
        "name" : "isContinuousCollisionDetectionEnabled",
        "type" : "Bool"
      },
      {
        "comment" : "A tuple of Boolean values that you use to lock the position of the physics body along any of the three axes.  You can restrict movement of the body along one or more axes by setting the corresponding item in the tuple to `true`. For example, if you set the `x` and the `z` items in the tuple to `true`, then the body can move only along the y-axis. By default, movement isnâ€™t restricted.",
        "complete" : "var isTranslationLocked: (x: Bool, y: Bool, z: Bool)",
        "name" : "isTranslationLocked",
        "type" : "(x: Bool, y: Bool, z: Bool)"
      },
      {
        "comment" : "The physics bodyâ€™s material properties, like friction.  By default, the bodyâ€™s material resource is set to ``PhysicsMaterialResource\/default``, which provides a modest amount of friction and restitution (bounciness).",
        "complete" : "var material: PhysicsMaterialResource",
        "name" : "material",
        "type" : "PhysicsMaterialResource"
      },
      {
        "comment" : "A tuple of Boolean values that you use to lock rotation of the physics body around any of the three axes.  For any one of the three Booleans in the tuple that you set to `true`, rotation is restricted on the axis represented by that item. For example, if you set the `x` item to true, then the body canâ€™t rotate around the x-axis. By default, rotation isnâ€™t restricted.",
        "complete" : "var isRotationLocked: (x: Bool, y: Bool, z: Bool)",
        "name" : "isRotationLocked",
        "type" : "(x: Bool, y: Bool, z: Bool)"
      },
      {
        "comment" : "The physics bodyâ€™s mass properties, like inertia and center of mass.  By default, the mass properties value is ``PhysicsMassProperties\/default``, which matches the properties of a unit sphere with mass of 1 kilogram.",
        "complete" : "var massProperties: PhysicsMassProperties",
        "name" : "massProperties",
        "type" : "PhysicsMassProperties"
      }
    ]
  },
  {
    "comment" : "A component that controls the motion of the body in physics simulations.  You specify velocities in the coordinate space of the physics simulation defined by ``ARView\/physicsOrigin``.  The behavior of an entity with a physics motion component depends on the entityâ€™s ``PhysicsBodyComponent\/mode`` setting:  - term ``PhysicsBodyMode\/static``: The physics simulation ignores the velocities. The entity doesnâ€™t move. - term ``PhysicsBodyMode\/kinematic``: The physics simulation moves the body according to the values you set for ``PhysicsMotionComponent\/angularVelocity`` and ``PhysicsMotionComponent\/linearVelocity``. - term ``PhysicsBodyMode\/dynamic``: The physics simulation overwrites the velocity values based on simulation, and ignores any values that you write.",
    "name" : "PhysicsMotionComponent",
    "properties" : [
      {
        "comment" : "The linear velocity of the body in the physics simulation.",
        "complete" : "var linearVelocity: SIMD3<Float>",
        "name" : "linearVelocity",
        "type" : "SIMD3<Float>"
      },
      {
        "comment" : "The angular velocity of the body around the center of mass.",
        "complete" : "var angularVelocity: SIMD3<Float>",
        "name" : "angularVelocity",
        "type" : "SIMD3<Float>"
      }
    ]
  },
  {
    "comment" : "A component that defines a point light source.",
    "name" : "PointLightComponent",
    "properties" : [
      {
        "comment" : "The point light attenuation radius in meters.  At any distance greater from the light that's greater than this value, the light's intensity is zero.",
        "complete" : "var attenuationRadius: Float",
        "name" : "attenuationRadius",
        "type" : "Float"
      },
      {
        "comment" : "The intensity of the point light, measured in lumen.",
        "complete" : "var intensity: Float",
        "name" : "intensity",
        "type" : "Float"
      }
    ]
  },
  {
    "comment" : "A component that defines a spotlight source.  A spot light illuminates a cone-shaped volume in the entity's forward direction (0, 0, -1) . To orient a spot light, use `HasTransform.look(at:from:upVector:)`.  To enable shadows, create a ``RealityKit\/DirectionalLightComponent\/Shadow`` and assign it to `HasDirectionalLight.shadow`. To disable shadows set `HasDirectionalLight.shadow` to `nil`.",
    "name" : "SpotLightComponent",
    "properties" : [
      {
        "comment" : "The inner angle of the spotlight in degrees.  A spot light's `innerAngle` and `outerAngle` reflect the size of the light's cone, which shines relative to the entity's forward direction (0, 0, -1). The light is at full  intensity between 0Â° and `innerAngle`. RealityKit attenuates the  light's intensity between `innerAngle` and `outerAngle`.  Beyond `outerAngle`, the light intensity is `0.0`.",
        "complete" : "var innerAngleInDegrees: Float",
        "name" : "innerAngleInDegrees",
        "type" : "Float"
      },
      {
        "comment" : "The attenuation radius in meters, after which the intensity of the spotlight is zero.",
        "complete" : "var attenuationRadius: Float",
        "name" : "attenuationRadius",
        "type" : "Float"
      },
      {
        "comment" : "The outer angle of the spotlight in degrees.  A spot light's `innerAngle` and `outerAngle` reflect the size of the light's cone, which shines relative to the entity's forward direction (0, 0, -1). The light is at full  intensity between 0Â° and `innerAngle`. RealityKit attenuates the  light's intensity between `innerAngle` and `outerAngle`.  Beyond `outerAngle`, the light intensity is `0.0`.",
        "complete" : "var outerAngleInDegrees: Float",
        "name" : "outerAngleInDegrees",
        "type" : "Float"
      },
      {
        "comment" : "The intensity of the spotlight measured in lumen.",
        "complete" : "var intensity: Float",
        "name" : "intensity",
        "type" : "Float"
      }
    ]
  },
  {
    "comment" : "A component that synchronizes an entity between processes and networked applications.  An entity acquires a ``SynchronizationComponent`` instance by adopting the ``HasSynchronization`` protocol. All entities have this component because the ``Entity`` base class adopts the protocol.",
    "name" : "SynchronizationComponent",
    "properties" : [
      {
        "comment" : "The entityâ€™s transfer ownership mode.  By default, the transfer mode is ``SynchronizationComponent\/OwnershipTransferMode-swift.enum\/autoAccept``. You can set it to ``SynchronizationComponent\/OwnershipTransferMode-swift.enum\/manual`` to require explicit confirmation of the request by your app.",
        "complete" : "var ownershipTransferMode: SynchronizationComponent.OwnershipTransferMode",
        "name" : "ownershipTransferMode",
        "type" : "SynchronizationComponent.OwnershipTransferMode"
      },
      {
        "comment" : "A Boolean that indicates whether the calling process owns the entity.",
        "complete" : "var isOwner: Bool { get }",
        "name" : "isOwner",
        "type" : "Bool"
      },
      {
        "comment" : "A unique identifier of an entity within a network session.",
        "complete" : "var identifier: UInt64 { get }",
        "name" : "identifier",
        "type" : "UInt64"
      }
    ]
  },
  {
    "comment" : "A component that defines the scale, rotation, and translation of an entity.  An entity acquires a ``Transform`` component, as well as a set of methods for manipulating the transform, by adopting the ``HasTransform`` protocol. This is true for all entities, because the ``Entity`` base class adopts the protocol.",
    "name" : "Transform",
    "properties" : [
      {
        "comment" : "The hash value.  Hash values are not guaranteed to be equal across different executions of your program. Do not save hash values to use during a future execution.  - Important: `hashValue` is deprecated as a `Hashable` requirement. To   conform to `Hashable`, implement the `hash(into:)` requirement instead.   The compiler provides an implementation for `hashValue` for you.",
        "complete" : "var hashValue: Int { get }",
        "name" : "hashValue",
        "type" : "Int"
      },
      {
        "comment" : "The scaling factor applied to the entity.",
        "complete" : "var scale: SIMD3<Float>",
        "name" : "scale",
        "type" : "SIMD3<Float>"
      },
      {
        "comment" : "The position of the entity along the x, y, and z axes.",
        "complete" : "var translation: SIMD3<Float>",
        "name" : "translation",
        "type" : "SIMD3<Float>"
      },
      {
        "comment" : "The rotation of the entity specified as a unit quaternion.",
        "complete" : "var rotation: simd_quatf",
        "name" : "rotation",
        "type" : "simd_quatf"
      },
      {
        "comment" : "The transform represented as a 4x4 matrix.  The ``Transform`` component canâ€™t represent all transforms that a general 4x4 matrix can represent. Using a 4x4 matrix to set the transform is therefore a lossy event that might result in certain transformations, like shear, being dropped.",
        "complete" : "var matrix: float4x4 { get set }",
        "name" : "matrix",
        "type" : "float4x4"
      }
    ]
  }
]